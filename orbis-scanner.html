<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ORBIS Scanner v3.0</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=DM+Mono:wght@400;500&family=DM+Sans:wght@300;400;500;600&display=swap');

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --ink:    #0a0a0f;
  --paper:  #f5f2eb;
  --accent: #1a1aff;
  --scan:   #ff3b00;
  --ok:     #00c853;
  --muted:  #8a8a9a;
  --border: #d8d4c8;
  --dark:   #0f0f1a;
}

html, body {
  height: 100%;
  background: var(--dark);
  color: #f0ede6;
  font-family: 'DM Sans', sans-serif;
  overflow: hidden;
}

header {
  position: fixed;
  top: 0; left: 0; right: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1.2rem 2rem;
  background: rgba(15,15,26,0.92);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255,255,255,0.06);
}
.logo-word {
  font-family: 'DM Serif Display', serif;
  font-size: 1.6rem;
  color: #f0ede6;
  line-height: 1;
}
.logo-word em { color: var(--accent); font-style: italic; }
.mode-badge {
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  letter-spacing: 0.1em;
  color: var(--scan);
  border: 1px solid var(--scan);
  padding: 0.2rem 0.5rem;
  border-radius: 2px;
}
.header-link {
  margin-left: auto;
  font-family: 'DM Mono', monospace;
  font-size: 0.72rem;
  color: var(--muted);
  text-decoration: none;
  border: 1px solid rgba(255,255,255,0.12);
  padding: 0.35rem 0.8rem;
  border-radius: 3px;
  transition: all 0.15s;
}
.header-link:hover { color: #f0ede6; border-color: rgba(255,255,255,0.3); }

.viewfinder {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

#video {
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  display: block;
}

.overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
}

.vignette {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center, transparent 30%, rgba(15,15,26,0.72) 60%, rgba(15,15,26,0.88) 100%);
}

.finder-ring {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: min(70vw, 70vh);
  height: min(70vw, 70vh);
  pointer-events: none;
}

.finder-ring svg {
  width: 100%; height: 100%;
  overflow: visible;
}

.scan-line {
  position: absolute;
  top: 50%;
  left: 50%;
  width: min(68vw, 68vh);
  height: 2px;
  transform: translate(-50%, -50%);
  background: linear-gradient(90deg, transparent, var(--scan), transparent);
  animation: scanline 2.4s ease-in-out infinite;
  opacity: 0.8;
  border-radius: 1px;
}
@keyframes scanline {
  0%   { top: calc(50% - min(34vw,34vh)); opacity: 0; }
  10%  { opacity: 0.8; }
  90%  { opacity: 0.8; }
  100% { top: calc(50% + min(34vw,34vh)); opacity: 0; }
}

.status-strip {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  padding: 1.5rem 2rem 2rem;
  background: linear-gradient(to top, rgba(15,15,26,0.98) 60%, transparent);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem;
}

.status-text {
  font-family: 'DM Mono', monospace;
  font-size: 0.8rem;
  letter-spacing: 0.08em;
  color: var(--muted);
  text-transform: uppercase;
  min-height: 1.2rem;
  transition: color 0.3s;
}
.status-text.searching  { color: var(--muted); }
.status-text.detecting  { color: #f0ede6; }
.status-text.found      { color: var(--ok); }
.status-text.error      { color: var(--scan); }

.debug-row {
  display: flex;
  gap: 1.5rem;
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  color: rgba(255,255,255,0.25);
}

.result-card {
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem;
  width: 100%;
  max-width: 420px;
  background: rgba(0, 200, 83, 0.12);
  border: 2px solid rgba(0, 200, 83, 0.4);
  border-radius: 12px;
  padding: 1.5rem;
  pointer-events: all;
  animation: slideUp 0.3s ease-out;
}
.result-card.visible { display: flex; }

@keyframes slideUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.result-header {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.result-title {
  font-family: 'DM Sans', sans-serif;
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--ok);
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.result-meta {
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  color: rgba(255,255,255,0.5);
}

.result-payload {
  width: 100%;
  font-family: 'DM Mono', monospace;
  font-size: 0.85rem;
  color: white;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  padding: 1rem;
  word-break: break-all;
  line-height: 1.6;
  max-height: 120px;
  overflow-y: auto;
}

.result-actions {
  width: 100%;
  display: flex;
  gap: 0.75rem;
}

.action-btn {
  flex: 1;
  padding: 0.9rem;
  border: none;
  border-radius: 8px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.88rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  pointer-events: all;
}

.action-btn.primary {
  background: var(--ok);
  color: white;
}
.action-btn.primary:hover {
  background: #00e567;
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(0,200,83,0.3);
}

.action-btn.secondary {
  background: rgba(255,255,255,0.1);
  color: white;
  border: 1px solid rgba(255,255,255,0.2);
}
.action-btn.secondary:hover {
  background: rgba(255,255,255,0.15);
}

.copy-toast {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%) translateY(-20px);
  background: var(--ok);
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.85rem;
  font-weight: 600;
  opacity: 0;
  pointer-events: none;
  transition: all 0.3s;
  z-index: 1000;
}
.copy-toast.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.permission-gate {
  position: fixed;
  inset: 0;
  background: var(--dark);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1.5rem;
  padding: 2rem;
  z-index: 200;
}
.permission-gate.hidden { display: none; }

.big-icon {
  font-size: 4rem;
  animation: float 3s ease-in-out infinite;
}
@keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-8px)} }

.permission-gate h2 {
  font-family: 'DM Serif Display', serif;
  font-size: 1.8rem;
  text-align: center;
  color: #f0ede6;
}
.permission-gate p {
  font-size: 0.85rem;
  color: var(--muted);
  text-align: center;
  line-height: 1.7;
  max-width: 340px;
}
.start-btn {
  padding: 1rem 2.5rem;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 4px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  letter-spacing: 0.04em;
  transition: background 0.15s;
}
.start-btn:hover { background: #3b3bff; }

.upload-label {
  font-family: 'DM Mono', monospace;
  font-size: 0.72rem;
  color: var(--muted);
  cursor: pointer;
  border: 1px solid rgba(255,255,255,0.12);
  padding: 0.6rem 1.2rem;
  border-radius: 3px;
  transition: all 0.15s;
}
.upload-label:hover { color: #f0ede6; border-color: rgba(255,255,255,0.3); }
#img-upload { display: none; }

.how-it-works {
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  color: rgba(255,255,255,0.2);
  text-align: center;
  line-height: 1.8;
  max-width: 340px;
}

.flash {
  position: fixed;
  inset: 0;
  background: rgba(0,200,83,0.12);
  pointer-events: none;
  opacity: 0;
  z-index: 50;
  transition: opacity 0.1s;
}
.flash.show { opacity: 1; }

#proc-canvas { display: none; }
</style>
</head>
<body>

<div class="permission-gate" id="permission-gate">
  <div class="big-icon">â—</div>
  <h2>ORBIS Scanner v3.0</h2>
  <p>Point your camera at any ORBIS code â€” on screen, printed, or in an image. Universal decoding works everywhere.</p>
  <button class="start-btn" id="start-btn">Enable Camera</button>
  <label class="upload-label">
    or scan an image file
    <input type="file" id="img-upload" accept="image/*">
  </label>
  <div class="how-it-works">
    SMART SCANNING<br>
    Auto-detects version Â· Error correction Â· Instant decode<br>
    Works screen-to-screen like QR codes
  </div>
</div>

<div class="viewfinder">
  <video id="video" autoplay playsinline muted></video>
</div>

<canvas id="proc-canvas"></canvas>

<div class="overlay">
  <div class="vignette"></div>
  <div class="finder-ring">
    <svg id="finder-svg" viewBox="0 0 300 300">
      <circle cx="150" cy="150" r="140" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="1.5"/>
      <path d="M 150 10 A 140 140 0 0 1 280 90" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M 290 150 A 140 140 0 0 1 210 276" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M 150 290 A 140 140 0 0 1 20 210" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M 10 150 A 140 140 0 0 1 90 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <line x1="145" y1="150" x2="155" y2="150" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
      <line x1="150" y1="145" x2="150" y2="155" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
    </svg>
  </div>
  <div class="scan-line" id="scan-line"></div>
</div>

<div class="flash" id="flash"></div>
<div class="copy-toast" id="copy-toast">âœ“ Copied to clipboard</div>

<header>
  <div class="logo-word"><em>O</em>RBIS</div>
  <div class="mode-badge">SCANNER V3</div>
  <a href="orbis-generator-v3.html" class="header-link">â† Generator</a>
</header>

<div class="status-strip">
  <div class="debug-row">
    <span id="fps-counter">â€” fps</span>
    <span id="circles-found">0 candidates</span>
    <span id="scan-count">0 frames</span>
  </div>
  <div class="status-text searching" id="status-text">Searching for ORBIS codeâ€¦</div>
  
  <div class="result-card" id="result-card">
    <div class="result-header">
      <span class="result-title">âœ“ Decoded</span>
      <span class="result-meta" id="result-meta">98% Â· Lite</span>
    </div>
    <div class="result-payload" id="result-payload">â€”</div>
    <div class="result-actions">
      <button class="action-btn primary" id="action-btn">Open Link</button>
      <button class="action-btn secondary" id="scan-another-btn">Scan Another</button>
    </div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ORBIS SCANNER V3.0 â€” Smart UX & Better Feedback
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const VERSIONS = {
  lite:     { rings: 10, sMax: 32, sFloor: 10, dataBytes: 17 },
  standard: { rings: 16, sMax: 40, sFloor: 12, dataBytes: 34 },
  pro:      { rings: 22, sMax: 48, sFloor: 14, dataBytes: 56 },
  ultra:    { rings: 28, sMax: 56, sFloor: 16, dataBytes: 83 },
  mega:     { rings: 35, sMax: 64, sFloor: 18, dataBytes: 117 },
};

function sectorCount(r, rMax, sMax, sFloor) {
  return Math.max(sFloor, Math.round(sMax * r / rMax));
}

// â”€â”€ Error Correction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function correctErrors(receivedBytes, dataLen, ecLen) {
  const data = receivedBytes.slice(0, dataLen);
  const ec = receivedBytes.slice(dataLen, dataLen + ecLen);
  
  let errors = 0;
  for (let i = 0; i < ecLen; i++) {
    let expected = 0;
    for (let j = 0; j < dataLen; j++) {
      expected ^= data[j] * (i + j + 1);
    }
    if ((expected & 0xFF) !== ec[i]) {
      errors++;
    }
  }
  
  if (errors > 0 && errors < ecLen / 3) {
    for (let byteIdx = 0; byteIdx < dataLen; byteIdx++) {
      for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
        const testData = new Uint8Array(data);
        testData[byteIdx] ^= (1 << bitIdx);
        
        let testErrors = 0;
        for (let i = 0; i < ecLen; i++) {
          let expected = 0;
          for (let j = 0; j < dataLen; j++) {
            expected ^= testData[j] * (i + j + 1);
          }
          if ((expected & 0xFF) !== ec[i]) testErrors++;
        }
        
        if (testErrors < errors) {
          return { data: testData, errors: testErrors, correctable: true };
        }
      }
    }
  }
  
  return { data, errors, correctable: errors < ecLen / 2 };
}

// â”€â”€ Data Decoding â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function decodePayload(dataBytes) {
  if (dataBytes.length < 2) return null;
  
  const length = (dataBytes[0] << 8) | dataBytes[1];
  if (length > dataBytes.length - 2 || length === 0) return null;
  
  const payload = dataBytes.slice(2, 2 + length);
  const decoder = new TextDecoder('utf-8', { fatal: false });
  
  try {
    const text = decoder.decode(payload);
    if (text.length === 0 || text.length > 500) return null;
    return text;
  } catch {
    return null;
  }
}

// â”€â”€ Bit Matrix Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function extractVersion(matrix) {
  if (!matrix[0] || matrix[0].length < 3) return 'lite';
  const megaBit = matrix[0][0];
  const marker = (matrix[0][1] << 1) | matrix[0][2];
  
  if (megaBit === 1 && marker === 0b11) return 'mega';
  
  return ['lite', 'standard', 'pro', 'ultra'][marker] || 'lite';
}

function matrixToBytes(matrix, version) {
  const bits = [];
  for (const row of matrix) {
    for (const bit of row) {
      bits.push(bit);
    }
  }
  
  const dataBits = bits.slice(3);
  
  const bytes = [];
  for (let i = 0; i < dataBits.length; i += 8) {
    let byte = 0;
    for (let j = 0; j < 8 && i + j < dataBits.length; j++) {
      byte = (byte << 1) | (dataBits[i + j] || 0);
    }
    bytes.push(byte);
  }
  
  return new Uint8Array(bytes);
}

function decodeBitMatrix(matrix) {
  const version = extractVersion(matrix);
  const cfg = VERSIONS[version];
  const allBytes = matrixToBytes(matrix, version);
  const dataLen = cfg.dataBytes;
  const ecLen = Math.ceil(dataLen * 0.3);
  const corrected = correctErrors(allBytes, dataLen, ecLen);
  const payload = decodePayload(corrected.data);
  
  return {
    payload,
    version,
    errors: corrected.errors,
    correctable: corrected.correctable,
    confidence: payload ? Math.max(50, 100 - corrected.errors * 5) : 0
  };
}

// â”€â”€ Image Processing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toGray(r, g, b) {
  return (0.299 * r + 0.587 * g + 0.114 * b) | 0;
}

function detectCircles(imgData, width, height) {
  const grayData = new Uint8Array(width * height);
  let sum = 0;
  
  for (let i = 0; i < width * height; i++) {
    grayData[i] = toGray(imgData.data[i*4], imgData.data[i*4+1], imgData.data[i*4+2]);
    sum += grayData[i];
  }
  
  const mean = sum / grayData.length;
  const threshold = mean * 0.55;
  
  const candidates = [];
  const step = 6;
  
  const minR = Math.floor(Math.min(width, height) * 0.18);
  const maxR = Math.floor(Math.min(width, height) * 0.48);
  const radii = [];
  for (let r = minR; r <= maxR; r += Math.max(3, Math.floor((maxR - minR) / 8))) {
    radii.push(r);
  }
  
  for (const R of radii) {
    const perimPoints = Math.max(24, Math.floor(2 * Math.PI * R / 4));
    const angles = [];
    for (let i = 0; i < perimPoints; i++) {
      angles.push(i / perimPoints * 2 * Math.PI);
    }
    
    for (let cy = R + step; cy < height - R; cy += step) {
      for (let cx = R + step; cx < width - R; cx += step) {
        let darkCount = 0;
        for (const angle of angles) {
          const px = Math.round(cx + Math.cos(angle) * R);
          const py = Math.round(cy + Math.sin(angle) * R);
          if (px >= 0 && px < width && py >= 0 && py < height) {
            if (grayData[py * width + px] < threshold) darkCount++;
          }
        }
        const score = darkCount / perimPoints;
        if (score > 0.4) {
          candidates.push({ cx, cy, r: R, score, grayData, threshold });
        }
      }
    }
  }
  
  candidates.sort((a, b) => b.score - a.score);
  const merged = [];
  for (const c of candidates) {
    const dupe = merged.find(m => Math.hypot(m.cx - c.cx, m.cy - c.cy) < c.r * 0.5);
    if (!dupe) merged.push(c);
    if (merged.length >= 4) break;
  }
  
  return merged;
}

function sampleBitMatrix(grayData, width, height, cx, cy, R, version, threshold) {
  const cfg = VERSIONS[version];
  const { sMax, rings, sFloor } = cfg;
  
  const dataInFrac  = 0.25;
  const dataOutFrac = 0.72;
  const usableFrac  = dataOutFrac - dataInFrac;
  const ringFrac    = usableFrac / rings;
  
  const matrix = [];
  
  for (let r = 0; r < rings; r++) {
    const innerFrac = dataInFrac + r * ringFrac;
    const outerFrac = dataInFrac + (r + 1) * ringFrac;
    const midFrac   = (innerFrac + outerFrac) / 2;
    const numSect   = sectorCount(r + 1, rings, sMax, sFloor);
    const angStep   = (2 * Math.PI) / numSect;
    
    const row = [];
    for (let s = 0; s < numSect; s++) {
      const angle = s * angStep + angStep / 2 - Math.PI / 2;
      let darkCount = 0, sampleCount = 0;
      
      for (const dr of [-0.2, 0, 0.2]) {
        const sampleR = R * (midFrac + dr * ringFrac);
        for (const da of [-0.3, 0, 0.3]) {
          const a2 = angle + da * angStep;
          const px = Math.round(cx + Math.cos(a2) * sampleR);
          const py = Math.round(cy + Math.sin(a2) * sampleR);
          if (px >= 0 && px < width && py >= 0 && py < height) {
            if (grayData[py * width + px] < threshold) darkCount++;
            sampleCount++;
          }
        }
      }
      
      row.push(sampleCount > 0 && (darkCount / sampleCount) > 0.32 ? 1 : 0);
    }
    matrix.push(row);
  }
  
  return matrix;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SCAN LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const video = document.getElementById('video');
const canvas = document.getElementById('proc-canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

const PROC_W = 320;
const PROC_H = 240;

let scanning = false;
let frameCount = 0;
let lastFpsTime = performance.now();
let fps = 0;
let resultFound = false;
let animFrame = null;

function setStatus(msg, cls = 'searching') {
  const el = document.getElementById('status-text');
  el.textContent = msg;
  el.className = 'status-text ' + cls;
}

function showCopyToast() {
  const toast = document.getElementById('copy-toast');
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 2000);
}

function showResult(payload, confidence, version) {
  resultFound = true;
  
  // Flash effect
  const fl = document.getElementById('flash');
  fl.classList.add('show');
  setTimeout(() => fl.classList.remove('show'), 300);
  
  // Pause scan line animation
  document.getElementById('scan-line').style.animationPlayState = 'paused';
  
  // Auto-copy to clipboard
  if (navigator.clipboard) {
    navigator.clipboard.writeText(payload).then(() => {
      showCopyToast();
    }).catch(() => {});
  }
  
  // Update result card
  document.getElementById('result-payload').textContent = payload;
  document.getElementById('result-meta').textContent = `${confidence}% Â· ${version.toUpperCase()}`;
  document.getElementById('result-card').classList.add('visible');
  
  setStatus('', 'found');
  
  // Smart action button
  const actionBtn = document.getElementById('action-btn');
  const isUrl = payload.startsWith('http://') || payload.startsWith('https://');
  
  if (isUrl) {
    actionBtn.textContent = 'ğŸ”— Open Link';
    actionBtn.onclick = () => window.open(payload, '_blank');
  } else {
    actionBtn.textContent = 'ğŸ“‹ Copy Again';
    actionBtn.onclick = () => {
      navigator.clipboard?.writeText(payload);
      showCopyToast();
    };
  }
}

function scanAnother() {
  resultFound = false;
  document.getElementById('result-card').classList.remove('visible');
  document.getElementById('scan-line').style.animationPlayState = 'running';
  setStatus('Searching for ORBIS codeâ€¦', 'searching');
}

function processFrame() {
  if (!scanning) return;
  
  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime > 800) {
    fps = Math.round(frameCount / ((now - lastFpsTime) / 1000));
    frameCount = 0;
    lastFpsTime = now;
    document.getElementById('fps-counter').textContent = fps + ' fps';
  }
  
  if (resultFound) {
    animFrame = requestAnimationFrame(processFrame);
    return;
  }
  
  canvas.width = PROC_W;
  canvas.height = PROC_H;
  ctx.drawImage(video, 0, 0, PROC_W, PROC_H);
  const imgData = ctx.getImageData(0, 0, PROC_W, PROC_H);
  
  const circles = detectCircles(imgData, PROC_W, PROC_H);
  document.getElementById('circles-found').textContent = circles.length + ' candidates';
  document.getElementById('scan-count').textContent = 
    (parseInt(document.getElementById('scan-count').textContent) || 0) + 1 + ' frames';
  
  if (circles.length === 0) {
    setStatus('Searching for ORBIS codeâ€¦', 'searching');
    animFrame = requestAnimationFrame(processFrame);
    return;
  }
  
  setStatus('Circular pattern detected â€” decodingâ€¦', 'detecting');
  
  for (const circ of circles) {
    for (const versionName of ['lite', 'standard', 'pro', 'ultra', 'mega']) {
      try {
        const sampled = sampleBitMatrix(
          circ.grayData, PROC_W, PROC_H,
          circ.cx, circ.cy, circ.r,
          versionName, circ.threshold
        );
        
        const decoded = decodeBitMatrix(sampled);
        
        if (decoded.payload && decoded.confidence > 60) {
          showResult(decoded.payload, decoded.confidence, decoded.version);
          animFrame = requestAnimationFrame(processFrame);
          return;
        }
      } catch (err) {}
    }
  }
  
  setStatus('Pattern found â€” improving readâ€¦', 'detecting');
  animFrame = requestAnimationFrame(processFrame);
}

function processImage(imageEl) {
  const w = imageEl.naturalWidth || imageEl.width;
  const h = imageEl.naturalHeight || imageEl.height;
  const scale = Math.min(480 / w, 480 / h);
  const pw = Math.floor(w * scale);
  const ph = Math.floor(h * scale);
  
  canvas.width = pw;
  canvas.height = ph;
  ctx.drawImage(imageEl, 0, 0, pw, ph);
  const imgData = ctx.getImageData(0, 0, pw, ph);
  
  setStatus('Analyzing imageâ€¦', 'detecting');
  
  const circles = detectCircles(imgData, pw, ph);
  
  for (const circ of circles) {
    for (const versionName of ['lite', 'standard', 'pro', 'ultra', 'mega']) {
      try {
        const sampled = sampleBitMatrix(
          circ.grayData, pw, ph,
          circ.cx, circ.cy, circ.r,
          versionName, circ.threshold
        );
        
        const decoded = decodeBitMatrix(sampled);
        
        if (decoded.payload && decoded.confidence > 50) {
          showResult(decoded.payload, decoded.confidence, decoded.version);
          return;
        }
      } catch (err) {}
    }
  }
  
  setStatus(circles.length > 0 ? 'Could not decode â€” pattern unclear' : 'No ORBIS code detected', 'error');
}

async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { 
        facingMode: 'environment', 
        width: { ideal: 1280 }, 
        height: { ideal: 720 } 
      }
    });
    video.srcObject = stream;
    await video.play();
    scanning = true;
    document.getElementById('permission-gate').classList.add('hidden');
    setStatus('Searching for ORBIS codeâ€¦', 'searching');
    processFrame();
  } catch (err) {
    setStatus('Camera access denied. Use image upload instead.', 'error');
    console.warn('Camera error:', err);
  }
}

// â”€â”€ Event Bindings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('start-btn').addEventListener('click', startCamera);

document.getElementById('img-upload').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('permission-gate').classList.add('hidden');
  setStatus('Loading imageâ€¦', 'detecting');
  const img = new Image();
  img.onload = () => processImage(img);
  img.src = URL.createObjectURL(file);
});

document.getElementById('scan-another-btn').addEventListener('click', scanAnother);

navigator.permissions?.query({ name: 'camera' }).then(p => {
  if (p.state === 'granted') startCamera();
}).catch(() => {});
</script>
</body>
</html>
