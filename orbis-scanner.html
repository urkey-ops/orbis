<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ORBIS Scanner v2.0</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=DM+Serif+Display:ital@0;1&family=DM+Mono:wght@400;500&family=DM+Sans:wght@300;400;500;600&display=swap');

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --ink:    #0a0a0f;
  --paper:  #f5f2eb;
  --accent: #1a1aff;
  --scan:   #ff3b00;
  --ok:     #00c853;
  --muted:  #8a8a9a;
  --border: #d8d4c8;
  --dark:   #0f0f1a;
}

html, body {
  height: 100%;
  background: var(--dark);
  color: #f0ede6;
  font-family: 'DM Sans', sans-serif;
  overflow: hidden;
}

header {
  position: fixed;
  top: 0; left: 0; right: 0;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1.2rem 2rem;
  background: rgba(15,15,26,0.92);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255,255,255,0.06);
}
.logo-word {
  font-family: 'DM Serif Display', serif;
  font-size: 1.6rem;
  color: #f0ede6;
  line-height: 1;
}
.logo-word em { color: var(--accent); font-style: italic; }
.mode-badge {
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  letter-spacing: 0.1em;
  color: var(--scan);
  border: 1px solid var(--scan);
  padding: 0.2rem 0.5rem;
  border-radius: 2px;
}
.header-link {
  margin-left: auto;
  font-family: 'DM Mono', monospace;
  font-size: 0.72rem;
  color: var(--muted);
  text-decoration: none;
  border: 1px solid rgba(255,255,255,0.12);
  padding: 0.35rem 0.8rem;
  border-radius: 3px;
  transition: all 0.15s;
}
.header-link:hover { color: #f0ede6; border-color: rgba(255,255,255,0.3); }

.viewfinder {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

#video {
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  display: block;
}

.overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
}

.vignette {
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center, transparent 30%, rgba(15,15,26,0.72) 60%, rgba(15,15,26,0.88) 100%);
}

.finder-ring {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: min(70vw, 70vh);
  height: min(70vw, 70vh);
  pointer-events: none;
}

.finder-ring svg {
  width: 100%; height: 100%;
  overflow: visible;
}

.scan-line {
  position: absolute;
  top: 50%;
  left: 50%;
  width: min(68vw, 68vh);
  height: 2px;
  transform: translate(-50%, -50%);
  background: linear-gradient(90deg, transparent, var(--scan), transparent);
  animation: scanline 2.4s ease-in-out infinite;
  opacity: 0.8;
  border-radius: 1px;
}
@keyframes scanline {
  0%   { top: calc(50% - min(34vw,34vh)); opacity: 0; }
  10%  { opacity: 0.8; }
  90%  { opacity: 0.8; }
  100% { top: calc(50% + min(34vw,34vh)); opacity: 0; }
}

.status-strip {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  padding: 1.5rem 2rem 2rem;
  background: linear-gradient(to top, rgba(15,15,26,0.98) 60%, transparent);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.75rem;
}

.status-text {
  font-family: 'DM Mono', monospace;
  font-size: 0.8rem;
  letter-spacing: 0.08em;
  color: var(--muted);
  text-transform: uppercase;
  min-height: 1.2rem;
  transition: color 0.3s;
}
.status-text.searching  { color: var(--muted); }
.status-text.detecting  { color: #f0ede6; }
.status-text.found      { color: var(--ok); }
.status-text.error      { color: var(--scan); }

.debug-row {
  display: flex;
  gap: 1.5rem;
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  color: rgba(255,255,255,0.25);
}

.confirm-row {
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  width: 100%;
  max-width: 380px;
}
.confirm-row.visible { display: flex; }

.result-url {
  font-family: 'DM Mono', monospace;
  font-size: 0.78rem;
  color: var(--ok);
  background: rgba(0,200,83,0.08);
  border: 1px solid rgba(0,200,83,0.25);
  border-radius: 4px;
  padding: 0.7rem 1rem;
  width: 100%;
  text-align: center;
  word-break: break-all;
}

.open-btn {
  width: 100%;
  padding: 0.9rem;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 4px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.88rem;
  font-weight: 600;
  letter-spacing: 0.04em;
  cursor: pointer;
  transition: background 0.15s, transform 0.1s;
  pointer-events: all;
}
.open-btn:hover { background: #3b3bff; }
.open-btn:active { transform: scale(0.99); }

.dismiss-btn {
  background: none;
  border: none;
  color: var(--muted);
  font-family: 'DM Mono', monospace;
  font-size: 0.7rem;
  cursor: pointer;
  pointer-events: all;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}
.dismiss-btn:hover { color: #f0ede6; }

.permission-gate {
  position: fixed;
  inset: 0;
  background: var(--dark);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 1.5rem;
  padding: 2rem;
  z-index: 200;
}
.permission-gate.hidden { display: none; }

.big-icon {
  font-size: 4rem;
  animation: float 3s ease-in-out infinite;
}
@keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-8px)} }

.permission-gate h2 {
  font-family: 'DM Serif Display', serif;
  font-size: 1.8rem;
  text-align: center;
  color: #f0ede6;
}
.permission-gate p {
  font-size: 0.85rem;
  color: var(--muted);
  text-align: center;
  line-height: 1.7;
  max-width: 340px;
}
.start-btn {
  padding: 1rem 2.5rem;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 4px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  letter-spacing: 0.04em;
  transition: background 0.15s;
}
.start-btn:hover { background: #3b3bff; }

.upload-label {
  font-family: 'DM Mono', monospace;
  font-size: 0.72rem;
  color: var(--muted);
  cursor: pointer;
  border: 1px solid rgba(255,255,255,0.12);
  padding: 0.6rem 1.2rem;
  border-radius: 3px;
  transition: all 0.15s;
}
.upload-label:hover { color: #f0ede6; border-color: rgba(255,255,255,0.3); }
#img-upload { display: none; }

.how-it-works {
  font-family: 'DM Mono', monospace;
  font-size: 0.65rem;
  color: rgba(255,255,255,0.2);
  text-align: center;
  line-height: 1.8;
  max-width: 340px;
}

.flash {
  position: fixed;
  inset: 0;
  background: rgba(0,200,83,0.12);
  pointer-events: none;
  opacity: 0;
  z-index: 50;
  transition: opacity 0.1s;
}
.flash.show { opacity: 1; }

#proc-canvas { display: none; }
</style>
</head>
<body>

<div class="permission-gate" id="permission-gate">
  <div class="big-icon">◎</div>
  <h2>ORBIS Scanner v2.0</h2>
  <p>Point your camera at any ORBIS code. The scanner reads the encoded data directly from the pattern — no database lookup required.</p>
  <button class="start-btn" id="start-btn">Enable Camera</button>
  <label class="upload-label">
    or scan an image file
    <input type="file" id="img-upload" accept="image/*">
  </label>
  <div class="how-it-works">
    HOW IT WORKS<br>
    Circle detection → anchor validation → bit sampling → real data decoding<br>
    Works like QR codes — universal decoding
  </div>
</div>

<div class="viewfinder">
  <video id="video" autoplay playsinline muted></video>
</div>

<canvas id="proc-canvas"></canvas>

<div class="overlay">
  <div class="vignette"></div>
  <div class="finder-ring">
    <svg id="finder-svg" viewBox="0 0 300 300">
      <circle cx="150" cy="150" r="140" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="1.5"/>
      <path d="M 150 10 A 140 140 0 0 1 280 90" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M 290 150 A 140 140 0 0 1 210 276" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M 150 290 A 140 140 0 0 1 20 210" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M 10 150 A 140 140 0 0 1 90 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round"/>
      <line x1="145" y1="150" x2="155" y2="150" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
      <line x1="150" y1="145" x2="150" y2="155" stroke="rgba(255,255,255,0.3)" stroke-width="1"/>
    </svg>
  </div>
  <div class="scan-line" id="scan-line"></div>
</div>

<div class="flash" id="flash"></div>

<header>
  <div class="logo-word"><em>O</em>RBIS</div>
  <div class="mode-badge">SCANNER V2</div>
  <a href="orbis-generator-v2.html" class="header-link">← Generator</a>
</header>

<div class="status-strip">
  <div class="debug-row">
    <span id="fps-counter">— fps</span>
    <span id="circles-found">0 candidates</span>
    <span id="scan-count">0 frames</span>
  </div>
  <div class="status-text searching" id="status-text">Searching for ORBIS code…</div>
  <div class="confirm-row" id="confirm-row">
    <div class="result-url" id="result-url">—</div>
    <button class="open-btn" id="open-btn">Open URL</button>
    <button class="dismiss-btn" id="dismiss-btn">Scan again</button>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════
//  ORBIS DECODER V2.0 — REAL DATA DECODING
//  Now actually decodes data from the pattern (like QR codes)
//  NO localStorage dependency — universal decoding
// ═══════════════════════════════════════════════════════════════════════════

const VERSIONS = {
  lite:     { rings: 10, sMax: 32, sFloor: 10, dataBytes: 17 },
  standard: { rings: 16, sMax: 40, sFloor: 12, dataBytes: 34 },
  pro:      { rings: 22, sMax: 48, sFloor: 14, dataBytes: 56 },
};

function sectorCount(r, rMax, sMax, sFloor) {
  return Math.max(sFloor, Math.round(sMax * r / rMax));
}

// ═══════════════════════════════════════════════════════════════════════════
//  ERROR CORRECTION (matching generator)
// ═══════════════════════════════════════════════════════════════════════════

function correctErrors(receivedBytes, dataLen, ecLen) {
  const data = receivedBytes.slice(0, dataLen);
  const ec = receivedBytes.slice(dataLen, dataLen + ecLen);
  
  // Verify EC codes
  let errors = 0;
  for (let i = 0; i < ecLen; i++) {
    let expected = 0;
    for (let j = 0; j < dataLen; j++) {
      expected ^= data[j] * (i + j + 1);
    }
    if ((expected & 0xFF) !== ec[i]) {
      errors++;
    }
  }
  
  // Simple single-bit error correction
  if (errors > 0 && errors < ecLen / 3) {
    // Try flipping bits in data to see if EC improves
    for (let byteIdx = 0; byteIdx < dataLen; byteIdx++) {
      for (let bitIdx = 0; bitIdx < 8; bitIdx++) {
        const testData = new Uint8Array(data);
        testData[byteIdx] ^= (1 << bitIdx);
        
        let testErrors = 0;
        for (let i = 0; i < ecLen; i++) {
          let expected = 0;
          for (let j = 0; j < dataLen; j++) {
            expected ^= testData[j] * (i + j + 1);
          }
          if ((expected & 0xFF) !== ec[i]) testErrors++;
        }
        
        if (testErrors < errors) {
          return { data: testData, errors: testErrors, correctable: true };
        }
      }
    }
  }
  
  return { data, errors, correctable: errors < ecLen / 2 };
}

// ═══════════════════════════════════════════════════════════════════════════
//  DATA DECODING
// ═══════════════════════════════════════════════════════════════════════════

function decodePayload(dataBytes) {
  if (dataBytes.length < 2) return null;
  
  const length = (dataBytes[0] << 8) | dataBytes[1];
  if (length > dataBytes.length - 2 || length === 0) return null;
  
  const payload = dataBytes.slice(2, 2 + length);
  const decoder = new TextDecoder('utf-8', { fatal: false });
  
  try {
    const text = decoder.decode(payload);
    // Validate it's reasonable text
    if (text.length === 0 || text.length > 500) return null;
    return text;
  } catch {
    return null;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
//  BIT MATRIX EXTRACTION
// ═══════════════════════════════════════════════════════════════════════════

function extractVersion(matrix) {
  if (!matrix[0] || matrix[0].length < 2) return 'lite';
  const marker = (matrix[0][0] << 1) | matrix[0][1];
  return ['lite', 'standard', 'pro'][marker] || 'lite';
}

function matrixToBytes(matrix, version) {
  const cfg = VERSIONS[version];
  
  // Flatten matrix to bits
  const bits = [];
  for (const row of matrix) {
    for (const bit of row) {
      bits.push(bit);
    }
  }
  
  // Skip first 2 version bits
  const dataBits = bits.slice(2);
  
  // Convert to bytes
  const bytes = [];
  for (let i = 0; i < dataBits.length; i += 8) {
    let byte = 0;
    for (let j = 0; j < 8 && i + j < dataBits.length; j++) {
      byte = (byte << 1) | (dataBits[i + j] || 0);
    }
    bytes.push(byte);
  }
  
  return new Uint8Array(bytes);
}

function decodeBitMatrix(matrix) {
  // Extract version from first 2 bits
  const version = extractVersion(matrix);
  const cfg = VERSIONS[version];
  
  // Convert matrix to bytes
  const allBytes = matrixToBytes(matrix, version);
  
  // Split data and EC
  const dataLen = cfg.dataBytes;
  const ecLen = Math.ceil(dataLen * 0.3);
  
  // Apply error correction
  const corrected = correctErrors(allBytes, dataLen, ecLen);
  
  // Decode payload
  const payload = decodePayload(corrected.data);
  
  return {
    payload,
    version,
    errors: corrected.errors,
    correctable: corrected.correctable,
    confidence: payload ? Math.max(50, 100 - corrected.errors * 5) : 0
  };
}

// ═══════════════════════════════════════════════════════════════════════════
//  IMAGE PROCESSING
// ═══════════════════════════════════════════════════════════════════════════

function toGray(r, g, b) {
  return (0.299 * r + 0.587 * g + 0.114 * b) | 0;
}

function detectCircles(imgData, width, height) {
  const grayData = new Uint8Array(width * height);
  let sum = 0;
  
  for (let i = 0; i < width * height; i++) {
    grayData[i] = toGray(imgData.data[i*4], imgData.data[i*4+1], imgData.data[i*4+2]);
    sum += grayData[i];
  }
  
  const mean = sum / grayData.length;
  const threshold = mean * 0.6;
  
  const candidates = [];
  const step = 6;
  
  const minR = Math.floor(Math.min(width, height) * 0.18);
  const maxR = Math.floor(Math.min(width, height) * 0.48);
  const radii = [];
  for (let r = minR; r <= maxR; r += Math.max(3, Math.floor((maxR - minR) / 8))) {
    radii.push(r);
  }
  
  for (const R of radii) {
    const perimPoints = Math.max(24, Math.floor(2 * Math.PI * R / 4));
    const angles = [];
    for (let i = 0; i < perimPoints; i++) {
      angles.push(i / perimPoints * 2 * Math.PI);
    }
    
    for (let cy = R + step; cy < height - R; cy += step) {
      for (let cx = R + step; cx < width - R; cx += step) {
        let darkCount = 0;
        for (const angle of angles) {
          const px = Math.round(cx + Math.cos(angle) * R);
          const py = Math.round(cy + Math.sin(angle) * R);
          if (px >= 0 && px < width && py >= 0 && py < height) {
            if (grayData[py * width + px] < threshold) darkCount++;
          }
        }
        const score = darkCount / perimPoints;
        if (score > 0.4) {
          candidates.push({ cx, cy, r: R, score, grayData, threshold });
        }
      }
    }
  }
  
  candidates.sort((a, b) => b.score - a.score);
  const merged = [];
  for (const c of candidates) {
    const dupe = merged.find(m => Math.hypot(m.cx - c.cx, m.cy - c.cy) < c.r * 0.5);
    if (!dupe) merged.push(c);
    if (merged.length >= 4) break;
  }
  
  return merged;
}

function validateAnchorPattern(grayData, width, height, cx, cy, R, threshold) {
  const NUM_PROBES = 60;
  const darkness = new Float32Array(NUM_PROBES);
  
  for (let i = 0; i < NUM_PROBES; i++) {
    const angle = (i / NUM_PROBES) * 2 * Math.PI - Math.PI / 2;
    let darkSum = 0, count = 0;
    
    for (let da = -1.5; da <= 1.5; da += 1.5) {
      const a2 = angle + (da / NUM_PROBES) * 2 * Math.PI;
      for (const dr of [-3, 0, 3]) {
        const r2 = R + dr;
        const px = Math.round(cx + Math.cos(a2) * r2);
        const py = Math.round(cy + Math.sin(a2) * r2);
        if (px >= 0 && px < width && py >= 0 && py < height) {
          darkSum += (grayData[py * width + px] < threshold) ? 1 : 0;
          count++;
        }
      }
    }
    darkness[i] = count > 0 ? darkSum / count : 0;
  }
  
  const peaks = [];
  for (let i = 0; i < NUM_PROBES; i++) {
    const prev = darkness[(i - 1 + NUM_PROBES) % NUM_PROBES];
    const next = darkness[(i + 1) % NUM_PROBES];
    if (darkness[i] > 0.45 && darkness[i] >= prev && darkness[i] >= next) {
      const last = peaks[peaks.length - 1];
      if (!last || i - last.idx >= 4) {
        peaks.push({ idx: i, val: darkness[i], angle: (i / NUM_PROBES) * 360 });
      }
    }
  }
  
  if (peaks.length >= 3) {
    for (let a = 0; a < peaks.length - 2; a++) {
      for (let b = a + 1; b < peaks.length - 1; b++) {
        for (let c = b + 1; c < peaks.length; c++) {
          const ab = Math.abs(peaks[b].angle - peaks[a].angle);
          const bc = Math.abs(peaks[c].angle - peaks[b].angle);
          const ca = 360 - ab - bc;
          if ([ab, bc, ca].every(d => Math.abs(d - 120) < 25)) {
            return { valid: true, anchors: [peaks[a], peaks[b], peaks[c]] };
          }
        }
      }
    }
  }
  
  return { valid: false };
}

function sampleBitMatrix(grayData, width, height, cx, cy, R, version, threshold) {
  const cfg = VERSIONS[version];
  const { sMax, rings, sFloor } = cfg;
  
  const dataInFrac  = 0.25;
  const dataOutFrac = 0.72;
  const usableFrac  = dataOutFrac - dataInFrac;
  const ringFrac    = usableFrac / rings;
  
  const matrix = [];
  
  for (let r = 0; r < rings; r++) {
    const innerFrac = dataInFrac + r * ringFrac;
    const outerFrac = dataInFrac + (r + 1) * ringFrac;
    const midFrac   = (innerFrac + outerFrac) / 2;
    const numSect   = sectorCount(r + 1, rings, sMax, sFloor);
    const angStep   = (2 * Math.PI) / numSect;
    
    const row = [];
    for (let s = 0; s < numSect; s++) {
      const angle = s * angStep + angStep / 2 - Math.PI / 2;
      let darkCount = 0, sampleCount = 0;
      
      // Multi-point sampling for robustness
      for (const dr of [-0.2, 0, 0.2]) {
        const sampleR = R * (midFrac + dr * ringFrac);
        for (const da of [-0.3, 0, 0.3]) {
          const a2 = angle + da * angStep;
          const px = Math.round(cx + Math.cos(a2) * sampleR);
          const py = Math.round(cy + Math.sin(a2) * sampleR);
          if (px >= 0 && px < width && py >= 0 && py < height) {
            if (grayData[py * width + px] < threshold) darkCount++;
            sampleCount++;
          }
        }
      }
      
      row.push(sampleCount > 0 && (darkCount / sampleCount) > 0.35 ? 1 : 0);
    }
    matrix.push(row);
  }
  
  return matrix;
}

// ═══════════════════════════════════════════════════════════════════════════
//  SCAN LOOP
// ═══════════════════════════════════════════════════════════════════════════

const video = document.getElementById('video');
const canvas = document.getElementById('proc-canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

const PROC_W = 320;
const PROC_H = 240;

let scanning = false;
let frameCount = 0;
let lastFpsTime = performance.now();
let fps = 0;
let resultFound = false;
let animFrame = null;

function setStatus(msg, cls = 'searching') {
  const el = document.getElementById('status-text');
  el.textContent = msg;
  el.className = 'status-text ' + cls;
}

function showResult(payload, confidence, version) {
  resultFound = true;
  
  const fl = document.getElementById('flash');
  fl.classList.add('show');
  setTimeout(() => fl.classList.remove('show'), 300);
  
  document.getElementById('result-url').textContent = payload;
  document.getElementById('confirm-row').classList.add('visible');
  document.getElementById('scan-line').style.animationPlayState = 'paused';
  setStatus(`✓ Decoded (${confidence}% · ${version})`, 'found');
  
  document.getElementById('open-btn').onclick = () => {
    if (payload.startsWith('http://') || payload.startsWith('https://')) {
      window.open(payload, '_blank');
    } else {
      navigator.clipboard?.writeText(payload);
      setStatus('Copied to clipboard', 'found');
    }
  };
}

function dismissResult() {
  resultFound = false;
  document.getElementById('confirm-row').classList.remove('visible');
  document.getElementById('scan-line').style.animationPlayState = 'running';
  setStatus('Searching for ORBIS code…', 'searching');
}

function processFrame() {
  if (!scanning) return;
  
  frameCount++;
  const now = performance.now();
  if (now - lastFpsTime > 800) {
    fps = Math.round(frameCount / ((now - lastFpsTime) / 1000));
    frameCount = 0;
    lastFpsTime = now;
    document.getElementById('fps-counter').textContent = fps + ' fps';
  }
  
  if (resultFound) {
    animFrame = requestAnimationFrame(processFrame);
    return;
  }
  
  canvas.width = PROC_W;
  canvas.height = PROC_H;
  ctx.drawImage(video, 0, 0, PROC_W, PROC_H);
  const imgData = ctx.getImageData(0, 0, PROC_W, PROC_H);
  
  const circles = detectCircles(imgData, PROC_W, PROC_H);
  document.getElementById('circles-found').textContent = circles.length + ' candidates';
  document.getElementById('scan-count').textContent = 
    (parseInt(document.getElementById('scan-count').textContent) || 0) + 1 + ' frames';
  
  if (circles.length === 0) {
    setStatus('Searching for ORBIS code…', 'searching');
    animFrame = requestAnimationFrame(processFrame);
    return;
  }
  
  setStatus('Circular pattern detected — decoding…', 'detecting');
  
  for (const circ of circles) {
    const anchor = validateAnchorPattern(
      circ.grayData, PROC_W, PROC_H, 
      circ.cx, circ.cy, circ.r, circ.threshold
    );
    
    for (const versionName of ['lite', 'standard', 'pro']) {
      try {
        const sampled = sampleBitMatrix(
          circ.grayData, PROC_W, PROC_H,
          circ.cx, circ.cy, circ.r,
          versionName, circ.threshold
        );
        
        const decoded = decodeBitMatrix(sampled);
        
        if (decoded.payload && decoded.confidence > 60) {
          showResult(decoded.payload, decoded.confidence, decoded.version);
          animFrame = requestAnimationFrame(processFrame);
          return;
        }
      } catch (err) {
        // Try next version
      }
    }
  }
  
  setStatus('Pattern found — improving read…', 'detecting');
  animFrame = requestAnimationFrame(processFrame);
}

function processImage(imageEl) {
  const w = imageEl.naturalWidth || imageEl.width;
  const h = imageEl.naturalHeight || imageEl.height;
  const scale = Math.min(480 / w, 480 / h);
  const pw = Math.floor(w * scale);
  const ph = Math.floor(h * scale);
  
  canvas.width = pw;
  canvas.height = ph;
  ctx.drawImage(imageEl, 0, 0, pw, ph);
  const imgData = ctx.getImageData(0, 0, pw, ph);
  
  setStatus('Analyzing image…', 'detecting');
  
  const circles = detectCircles(imgData, pw, ph);
  
  for (const circ of circles) {
    for (const versionName of ['lite', 'standard', 'pro']) {
      try {
        const sampled = sampleBitMatrix(
          circ.grayData, pw, ph,
          circ.cx, circ.cy, circ.r,
          versionName, circ.threshold
        );
        
        const decoded = decodeBitMatrix(sampled);
        
        if (decoded.payload && decoded.confidence > 50) {
          showResult(decoded.payload, decoded.confidence, decoded.version);
          return;
        }
      } catch (err) {}
    }
  }
  
  setStatus(circles.length > 0 ? 'Could not decode — pattern unclear' : 'No ORBIS code detected', 'error');
}

async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { 
        facingMode: 'environment', 
        width: { ideal: 1280 }, 
        height: { ideal: 720 } 
      }
    });
    video.srcObject = stream;
    await video.play();
    scanning = true;
    document.getElementById('permission-gate').classList.add('hidden');
    setStatus('Searching for ORBIS code…', 'searching');
    processFrame();
  } catch (err) {
    setStatus('Camera access denied. Use image upload instead.', 'error');
    console.warn('Camera error:', err);
  }
}

document.getElementById('start-btn').addEventListener('click', startCamera);

document.getElementById('img-upload').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  document.getElementById('permission-gate').classList.add('hidden');
  setStatus('Loading image…', 'detecting');
  const img = new Image();
  img.onload = () => processImage(img);
  img.src = URL.createObjectURL(file);
});

document.getElementById('dismiss-btn').addEventListener('click', dismissResult);

navigator.permissions?.query({ name: 'camera' }).then(p => {
  if (p.state === 'granted') startCamera();
}).catch(() => {});
</script>
</body>
</html>
