<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>QR_studio v9.1</title>
<meta http-equiv="Content-Security-Policy"
  content="default-src 'self';
           script-src 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net;
           worker-src blob:;
           style-src 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com;
           font-src https://fonts.gstatic.com;
           img-src 'self' data: blob:;
           connect-src https://unpkg.com https://cdn.jsdelivr.net;">
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://unpkg.com"/>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;500;600;700;800&display=swap"/>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --a:#b8f400;
  --a10:rgba(184,244,0,.10);
  --a20:rgba(184,244,0,.20);
  --dark:#090b08;
  --card:#0f1210;
  --bord:rgba(184,244,0,.09);
  --bord2:rgba(255,255,255,.06);
  --mut:rgba(255,255,255,.30);
  --danger:#ff4455;
  --warn:#ffa040;
}
html{scroll-behavior:smooth}
body{background:var(--dark);color:#e4ebe0;font-family:'Syne',sans-serif;min-height:100vh;overflow-x:hidden}
::-webkit-scrollbar{width:3px}
::-webkit-scrollbar-thumb{background:var(--bord);border-radius:2px}

input,textarea,select{
  font-family:inherit;background:rgba(255,255,255,.025);
  border:1px solid var(--bord2);border-radius:8px;
  color:#e4ebe0;padding:9px 12px;font-size:14px;width:100%;
  outline:none;transition:border-color .15s,box-shadow .15s;
}
input:focus,textarea:focus,select:focus{
  border-color:var(--a);box-shadow:0 0 0 3px rgba(184,244,0,.06)
}
input::placeholder,textarea::placeholder{color:rgba(255,255,255,.16)}
option{background:#141a12}
textarea{resize:vertical;min-height:68px}
button{cursor:pointer;font-family:inherit;border:none;transition:all .15s}
button:active{transform:scale(.96)}
input[type=range]{padding:0;background:none;border:none;accent-color:var(--a);cursor:pointer;height:4px}
input[type=range]:focus{box-shadow:none;border:none}
input.err{border-color:rgba(255,68,85,.5)!important;box-shadow:0 0 0 3px rgba(255,68,85,.06)!important}

@keyframes toastIn{from{opacity:0;transform:translateX(28px)}to{opacity:1;transform:none}}
@keyframes scanline{0%{top:-4px}100%{top:calc(100%+4px)}}
@keyframes popIn{from{opacity:0;transform:scale(.96)}to{opacity:1;transform:scale(1)}}

/* â”€â”€ layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
header{
  position:sticky;top:0;z-index:100;
  border-bottom:1px solid var(--bord);
  background:rgba(9,11,8,.92);
  backdrop-filter:blur(20px);
  padding:0 24px;
}
.hdr-inner{max-width:1060px;margin:0 auto;height:54px;display:flex;align-items:center;justify-content:space-between}
.logo{display:flex;align-items:center;gap:9px}
.logo-box{width:28px;height:28px;background:var(--a);border-radius:6px;display:grid;place-items:center;font-size:13px;flex-shrink:0}
.logo-name{font-family:'Space Mono',monospace;font-weight:700;font-size:16px;letter-spacing:-1px;color:#e4ebe0}
.logo-name span{color:var(--a)}
.hdr-badges{display:flex;gap:6px;align-items:center}
.hdr-badge{font-family:'Space Mono',monospace;font-size:10px;color:rgba(184,244,0,.45);letter-spacing:2px;border:1px solid var(--bord);padding:4px 10px;border-radius:20px}
.hdr-badge.v9{color:rgba(255,160,64,.8);border-color:rgba(255,160,64,.28)}

.main{max-width:1060px;margin:0 auto;padding:24px 24px 60px}
.grid{display:grid;grid-template-columns:1fr 380px;gap:16px;align-items:start}
@media(max-width:840px){.grid{grid-template-columns:1fr}}

.sec{background:var(--card);border:1px solid var(--bord);border-radius:14px;padding:20px}
.sec+.sec{margin-top:14px}
.sec-label{font-family:'Space Mono',monospace;font-size:9px;font-weight:700;
  color:rgba(184,244,0,.38);letter-spacing:3px;text-transform:uppercase;margin-bottom:16px}

/* â”€â”€ type selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.type-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:5px}
@media(max-width:580px){.type-grid{grid-template-columns:repeat(4,1fr)}}
.type-btn{display:flex;flex-direction:column;align-items:center;gap:4px;padding:8px 4px;
  border-radius:9px;border:1px solid var(--bord2);background:transparent;
  color:var(--mut);font-size:11px;font-weight:600}
.type-btn .ico{font-size:16px}
.type-btn.on{border-color:var(--a);background:var(--a10);color:var(--a)}
.type-btn:hover:not(.on){border-color:rgba(255,255,255,.12);color:rgba(255,255,255,.6)}

/* â”€â”€ form â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.lbl{font-family:'Space Mono',monospace;font-size:10px;font-weight:700;
  color:rgba(255,255,255,.24);letter-spacing:1.5px;text-transform:uppercase;margin-bottom:5px}
.fld{margin-bottom:12px}
.fld:last-child{margin-bottom:0}
.fld-err{font-size:10px;color:var(--danger);font-family:'Space Mono',monospace;margin-top:3px;display:none}
.fld-err.show{display:block}
.two{display:grid;grid-template-columns:1fr 1fr;gap:10px}

/* â”€â”€ settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.ec-row{display:flex;gap:6px;margin-bottom:14px}
.ecb{flex:1;padding:8px 0;border-radius:7px;border:1px solid var(--bord2);
  background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);
  font-weight:700;font-size:13px;font-family:'Space Mono',monospace}
.ecb.on{border-color:var(--a);background:var(--a);color:var(--dark)}
.ecb:hover:not(.on){border-color:rgba(255,255,255,.14);color:rgba(255,255,255,.6)}

.tog-row{display:flex;align-items:center;gap:9px;margin-bottom:0}
.tog{width:34px;height:18px;border-radius:9px;background:rgba(255,255,255,.08);
  position:relative;cursor:pointer;transition:background .18s;flex-shrink:0;border:none;padding:0;display:block}
.tog.on{background:var(--a)}
.tog-k{position:absolute;top:2px;left:2px;width:14px;height:14px;border-radius:50%;
  background:#fff;transition:left .18s;pointer-events:none}
.tog.on .tog-k{left:18px}
.tog-lbl{font-size:13px;color:var(--mut);cursor:pointer;user-select:none}

/* â”€â”€ preview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.preview-wrap{position:sticky;top:68px}
.prev-hdr{display:flex;align-items:center;justify-content:space-between;margin-bottom:14px}
.prev-title{font-family:'Space Mono',monospace;font-size:9px;font-weight:700;
  color:rgba(184,244,0,.38);letter-spacing:3px;text-transform:uppercase}

#qr-mount{
  display:flex;justify-content:center;align-items:center;
  min-height:260px;border-radius:12px;overflow:hidden;
  width:min(360px,100%);margin:0 auto 14px;
  transition:box-shadow .22s;
  position:relative;background:#fff;
}
#qr-mount.empty{background:rgba(255,255,255,.018)!important;outline:2px dashed var(--bord)}
#qr-mount.pass{box-shadow:0 0 0 2px var(--a),0 0 28px rgba(184,244,0,.10)}
#qr-mount.fail{box-shadow:0 0 0 2px var(--danger),0 0 28px rgba(255,68,85,.08)}
#qr-mount canvas{width:100%!important;height:auto!important;display:block;animation:popIn .18s ease}

.scanline-wrap{position:absolute;inset:0;pointer-events:none;overflow:hidden;border-radius:12px}
.scanline{position:absolute;left:0;right:0;height:2px;
  background:linear-gradient(90deg,transparent,var(--a),transparent);
  animation:scanline 1.1s ease-in-out infinite;opacity:.65}

.empty-hint{text-align:center;color:rgba(184,244,0,.14);pointer-events:none}
.empty-hint .big{font-size:44px;margin-bottom:8px;filter:grayscale(1)}
.empty-hint .txt{font-size:11px;font-family:'Space Mono',monospace;letter-spacing:1px}

/* â”€â”€ verify badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.vbadge{font-size:10px;font-family:'Space Mono',monospace;white-space:nowrap}
.vbadge.pass{color:var(--a)}
.vbadge.fail{color:var(--danger)}
.vbadge.checking{color:rgba(255,255,255,.22)}

/* â”€â”€ stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.qr-stats{display:flex;gap:5px;flex-wrap:wrap;margin-bottom:12px}
.stat-chip{padding:3px 8px;border-radius:5px;
  background:rgba(255,255,255,.025);border:1px solid rgba(255,255,255,.05);
  font-family:'Space Mono',monospace;font-size:10px;color:rgba(255,255,255,.28);
  display:flex;align-items:center;gap:4px}
.stat-chip .sv{color:rgba(184,244,0,.75);font-weight:700}
.stat-chip.warn .sv{color:var(--warn)}
.stat-chip.bad  .sv{color:var(--danger)}

/* â”€â”€ actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.dl-row{display:flex;gap:7px;margin-bottom:7px}
.btn-main{flex:1;padding:11px 0;border-radius:9px;border:none;
  background:var(--a);color:var(--dark);font-weight:700;font-size:13px;font-family:'Syne',sans-serif}
.btn-main:hover{background:#cbff1a}
.cp-row{display:flex;gap:7px}
.btn-g{flex:1;padding:8px 0;border-radius:9px;border:1px solid var(--bord2);
  background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-size:12px;font-weight:600}
.btn-g.done{background:var(--a10);color:var(--a);border-color:var(--bord)}
.btn-g:hover:not(.done){border-color:rgba(255,255,255,.14);color:rgba(255,255,255,.6)}

/* â”€â”€ toasts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#toasts{position:fixed;top:66px;right:18px;z-index:9999;
  display:flex;flex-direction:column;gap:7px;pointer-events:none}
.toast{padding:10px 15px;border-radius:10px;font-size:12px;font-weight:600;
  animation:toastIn .2s ease;display:flex;align-items:center;gap:7px;
  backdrop-filter:blur(16px);pointer-events:all}
.toast.ok{background:rgba(184,244,0,.13);border:1px solid rgba(184,244,0,.22);color:var(--a)}
.toast.er{background:rgba(255,68,85,.13);border:1px solid rgba(255,68,85,.22);color:var(--danger)}
.toast.wn{background:rgba(255,160,64,.13);border:1px solid rgba(255,160,64,.22);color:var(--warn)}
</style>
</head>
<body>
<div id="root"></div>
<div id="toasts"></div>
<script>
"use strict";
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   QR STUDIO v9 â€” Lightning fast. Minimal. Battle-tested.

   Architecture:
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚  Web Worker (off main thread)                                   â”‚
   â”‚  â€¢ qrcode-generator loaded via importScripts                    â”‚
   â”‚  â€¢ qr.make() + isDark() loop â†’ Uint8Array grid (transferable)   â”‚
   â”‚  â€¢ posts { grid, mc, version } back â€” zero copy                 â”‚
   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
   â”‚  Main thread                                                    â”‚
   â”‚  â€¢ Receives grid â†’ pure fillRect() draw â€” no isDark() here      â”‚
   â”‚  â€¢ jsQR verify (~60KB) on drawn canvas â€” ~5â€“15ms                â”‚
   â”‚  â€¢ Fallback: main-thread qrcode-generator if worker fails       â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   Libraries:
   â€¢ qrcode-generator@1.4.4 â€” isDark() API, lives in worker
   â€¢ jsQR@1.4.0              â€” 60KB, QR-only, replaces 500KB ZXing
   â€¢ No ZXing. No JSZip. No qr-code-styling. No logo. No color mode.

   Output: ISO/IEC 18004 â€” black on white, square modules,
   proportional quiet zone. What every bank and airline generates.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€ Allowed CDN origins â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const ALLOWED_ORIGINS = ["https://unpkg.com","https://cdn.jsdelivr.net"];
function isSafeScriptSrc(src) {
  try {
    const u = new URL(src);
    return ALLOWED_ORIGINS.some(o => u.origin === new URL(o).origin);
  } catch { return false; }
}

/* â”€â”€ Script loader â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const _sc = new Map();
function loadScript(src) {
  if (!isSafeScriptSrc(src)) return Promise.reject(new Error("Blocked: "+src));
  if (_sc.has(src)) return _sc.get(src);
  const p = new Promise((ok, fail) => {
    const s = document.createElement("script");
    s.src = src; s.onload = ok;
    s.onerror = () => { _sc.delete(src); fail(new Error("Load failed: "+src)); };
    document.head.appendChild(s);
  });
  _sc.set(src, p); return p;
}

/* â”€â”€ jsQR loader (main thread â€” verify only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _jsqrP = null;
function ensureJsQR() {
  if (!_jsqrP) _jsqrP = loadScript(
    "https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"
  ).then(() => {
    if (typeof window.jsQR !== "function") throw new Error("jsQR missing");
    return window.jsQR;
  }).catch(e => { _jsqrP = null; throw e; });
  return _jsqrP;
}

/* â”€â”€ qrcode-generator (main thread â€” fallback only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _qrgP = null;
function ensureQRG() {
  if (!_qrgP) _qrgP = loadScript(
    "https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"
  ).then(() => {
    if (typeof window.qrcode !== "function") throw new Error("qrcode-generator missing");
    return window.qrcode;
  }).catch(e => { _qrgP = null; throw e; });
  return _qrgP;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   WEB WORKER â€” inlined as Blob URL, keeps tool single-file.
   Loads qrcode-generator via importScripts (runs in worker scope).
   Posts Uint8Array grid as transferable â€” zero copy.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const WORKER_SRC = `
"use strict";
let libReady = false;
let libError = null;

// Load qrcode-generator inside worker
try {
  importScripts("https://unpkg.com/qrcode-generator@1.4.4/qrcode.js");
  if (typeof qrcode !== "function") throw new Error("qrcode not defined after importScripts");
  libReady = true;
} catch(e) {
  libError = e.message;
}

self.onmessage = function(e) {
  const { id, payload, ec } = e.data;

  if (!libReady) {
    self.postMessage({ id, ok: false, error: "Worker lib failed: " + libError });
    return;
  }

  try {
    // typeNumber 0 = auto-detect version
    const qr = qrcode(0, ec);
    qr.addData(payload);
    qr.make();

    const mc      = qr.getModuleCount();
    const version = (mc - 17) / 4;

    // Build flat Uint8Array grid â€” 1=dark, 0=light
    // Transferred as ArrayBuffer (zero copy across thread boundary)
    const grid = new Uint8Array(mc * mc);
    for (let r = 0; r < mc; r++)
      for (let c = 0; c < mc; c++)
        if (qr.isDark(r, c)) grid[r * mc + c] = 1;

    self.postMessage({ id, ok: true, grid, mc, version }, [grid.buffer]);

  } catch(err) {
    self.postMessage({ id, ok: false, error: err.message });
  }
};
`;

/* â”€â”€ Worker lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _worker     = null;
let _workerDead = false;
// Map of pending request id â†’ { resolve, reject, timer }
const _pending  = new Map();
let   _reqId    = 0;

// Monotonic generation token â€” guards against out-of-order worker responses
// and stale verify results overwriting a newer QR
let _genToken    = 0;
let _verifyToken = 0;

function getWorker() {
  if (_worker || _workerDead) return _worker;
  try {
    const blob = new Blob([WORKER_SRC], { type: "text/javascript" });
    const url  = URL.createObjectURL(blob);
    _worker = new Worker(url);

    _worker.onmessage = ({ data }) => {
      const entry = _pending.get(data.id);
      if (!entry) return;
      clearTimeout(entry.timer);
      _pending.delete(data.id);
      if (data.ok) entry.resolve(data);
      else         entry.reject(new Error(data.error || "Worker error"));
    };

    _worker.onerror = (e) => {
      // Reject all pending requests and mark worker dead
      _pending.forEach(({ reject, timer }) => {
        clearTimeout(timer);
        reject(new Error("Worker crashed: " + e.message));
      });
      _pending.clear();
      _worker = null;
      _workerDead = true; // stop retrying â€” fall back to main thread
    };

    URL.revokeObjectURL(url); // blob loaded, URL no longer needed
  } catch(e) {
    _workerDead = true;
    _worker = null;
  }
  return _worker;
}

function qrViaWorker(payload, ec) {
  return new Promise((resolve, reject) => {
    const w = getWorker();
    if (!w) { reject(new Error("Worker unavailable")); return; }

    const id    = ++_reqId;
    const timer = setTimeout(() => {
      if (_pending.has(id)) {
        _pending.delete(id);
        reject(new Error("Worker timeout"));
      }
    }, 6000);

    _pending.set(id, { resolve, reject, timer });
    w.postMessage({ id, payload, ec });
  });
}

/* Main-thread fallback â€” identical output, same grid format */
async function qrFallback(payload, ec) {
  const qrcGen = await ensureQRG();
  const qr     = qrcGen(0, ec);
  qr.addData(payload);
  qr.make();
  const mc      = qr.getModuleCount();
  const version = (mc - 17) / 4;
  const grid    = new Uint8Array(mc * mc);
  for (let r = 0; r < mc; r++)
    for (let c = 0; c < mc; c++)
      if (qr.isDark(r, c)) grid[r * mc + c] = 1;
  return { ok: true, grid, mc, version };
}

/* â”€â”€ Warmup: spin up worker + warm jsQR + pre-warm fallback â”€â”€â”€â”€â”€â”€â”€ */
// Worker importScripts run in background â€” zero main thread cost
// jsQR (~60KB) + qrcode-generator both warm before first keystroke
// qrcode-generator warmup ensures fallback path is ready if worker fails
window.addEventListener("load", () => {
  getWorker();                        // creates worker, importScripts fires immediately
  ensureJsQR().catch(() => {});       // warm jsQR
  ensureQRG().catch(() => {});        // warm fallback â€” same CDN, cached if worker already loaded it
});

/* â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function toast(msg, type = "ok", ms = 2800) {
  const c   = document.getElementById("toasts");
  const el  = document.createElement("div"); el.className = "toast "+type;
  const ico = document.createElement("span"); ico.textContent = {ok:"âœ“",er:"âœ•",wn:"âš "}[type]||"â€¢";
  const tx  = document.createElement("span"); tx.textContent = msg;
  el.appendChild(ico); el.appendChild(tx); c.appendChild(el);
  setTimeout(() => {
    el.style.cssText = "opacity:0;transform:translateX(28px);transition:.18s";
    setTimeout(() => el.remove(), 220);
  }, ms);
}

/* â”€â”€ Field length caps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const MAX_URL   = 2048;
const MAX_TEXT  = 2953;
const MAX_FIELD = 500;

function capField(val, max) {
  if (typeof val !== "string") return "";
  const enc = new TextEncoder().encode(val);
  if (enc.length <= max) return val;
  return new TextDecoder().decode(enc.slice(0, max));
}

/* â”€â”€ QR spec capacity table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const QR_CAP = {
  L:[17,32,53,78,106,134,154,192,230,271,321,367,425,458,520,586,644,718,792,858,929,1003,1091,1171,1273,1367,1465,1528,1628,1732,1840,1952,2068,2188,2303,2431,2563,2699,2809,2953],
  M:[14,26,42,62,84,106,122,152,180,213,251,287,331,362,412,450,504,560,624,666,711,779,857,911,997,1059,1125,1190,1264,1370,1452,1538,1628,1722,1809,1911,1989,2099,2213,2331],
  Q:[11,20,32,46,60,74,86,108,130,151,177,203,241,258,292,322,364,394,442,482,509,565,611,661,715,751,805,868,908,982,1030,1112,1168,1228,1283,1351,1423,1499,1579,1663],
  H:[7,14,24,34,44,58,64,84,98,119,137,155,177,194,220,250,280,310,338,382,403,439,461,511,535,593,625,658,698,742,790,842,898,958,983,1051,1093,1139,1219,1273]
};
function moduleCount(v) { return 4*v+17; }

/* â”€â”€ Input validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function validateFields(type, fields) {
  const errs = {};
  if (type==="email"||type==="vcard") {
    const e = (fields.email||"").trim();
    if (e && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)) errs.email = "Invalid email format";
  }
  if (type==="url") {
    const u = (fields.url||"").trim();
    if (u && u.length > MAX_URL) {
      errs.url = `URL too long (max ${MAX_URL})`;
    } else if (u) {
      // Use URL constructor for reliable parsing â€” regex alone misses edge cases
      try {
        const testU = /^https?:\/\//i.test(u) ? u : "https://"+u;
        const parsed = new URL(testU);
        // Reject non-http(s) schemes that slipped through
        if (parsed.protocol !== "http:" && parsed.protocol !== "https:")
          errs.url = "Invalid URL";
      } catch {
        errs.url = "Invalid URL";
      }
    }
  }
  if (type==="wifi" && !(fields.ssid||"").trim()) errs.ssid = "SSID required";
  if (type==="vcard" && !(fields.firstName||"").trim() && !(fields.lastName||"").trim())
    errs.firstName = "At least one name required";
  return errs;
}

/* â”€â”€ RFC 6350 escaping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function vcEsc(v) { return capField(v,MAX_FIELD).replace(/\\/g,"\\\\").replace(/\n/g,"\\n").replace(/;/g,"\\;").replace(/,/g,"\\,"); }
function vcTel(v) { return (v||"").replace(/[^\d+\-().\s]/g,"").trim().slice(0,30); }
function wfEsc(v) { return (v||"").replace(/\\/g,"\\\\").replace(/:/g,"\\:").replace(/;/g,"\\;").replace(/,/g,"\\,"); }

/* â”€â”€ Data builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function buildData(type, f) {
  switch(type) {
    case "url": {
      let u = capField(f.url||"", MAX_URL).trim();
      if (u && !/^https?:\/\//i.test(u)) u = "https://"+u;
      return u;
    }
    case "text":  return capField(f.text||"", MAX_TEXT);
    case "email": return `mailto:${(f.email||"").trim()}?subject=${encodeURIComponent(capField(f.subject||"",200))}&body=${encodeURIComponent(capField(f.body||"",1000))}`;
    case "sms":   return `sms:${vcTel(f.phone)}${(f.message != null && f.message !== "")?`?body=${encodeURIComponent(capField(f.message,160))}`:""}`;  
    case "phone": return `tel:${vcTel(f.phone)}`;
    case "wifi":  return `WIFI:T:${f.security==="None"?"nopass":f.security||"WPA"};S:${wfEsc(capField(f.ssid||"",64))};P:${wfEsc(capField(f.password||"",64))};;`;
    case "vcard": {
      const fn = [f.firstName,f.lastName].filter(Boolean).map(vcEsc).join(" ");
      return [
        "BEGIN:VCARD","VERSION:3.0",
        `FN:${fn}`,
        `N:${vcEsc(f.lastName||"")};${vcEsc(f.firstName||"")};;;`,
        `ORG:${vcEsc(f.org||"")}`,
        `TEL:${vcTel(f.phone)}`,
        `EMAIL:${(f.email||"").trim().slice(0,254)}`,
        `URL:${(f.website||"").trim().slice(0,MAX_URL)}`,
        `ADR:;;${vcEsc(f.address||"")};;;;`,
        "END:VCARD"
      ].join("\n");
    }
    default: return "";
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RENDERER â€” draws from Uint8Array grid (no isDark() on main thread)
   Pure fillRect loop. Synchronous. Zero style branches.
   Black on white â€” ISO/IEC 18004 compliant by default.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function drawGrid(grid, mc, canvasSize, hasMargin) {
  const qzMods = hasMargin ? 4 : 0;
  const modSz  = canvasSize / (mc + qzMods * 2);
  const offset = qzMods * modSz;

  const canvas  = document.createElement("canvas");
  canvas.width  = canvasSize;
  canvas.height = canvasSize;
  const ctx     = canvas.getContext("2d", { willReadFrequently: true });

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, canvasSize, canvasSize);

  ctx.fillStyle = "#000000";
  for (let r = 0; r < mc; r++)
    for (let c = 0; c < mc; c++)
      if (grid[r * mc + c])
        ctx.fillRect(
          offset + c * modSz,
          offset + r * modSz,
          modSz, modSz
        );

  canvas.style.width  = "100%";
  canvas.style.height = "auto";
  return canvas;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   jsQR VERIFY â€” ~5â€“15ms on B&W canvas
   Purpose-built JS decoder, 60KB, no Java port overhead.
   Runs on main thread after draw â€” canvas pixels are already there.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
async function verifyWithJsQR(expectedData, canvas) {
  // Capture token before any await â€” if a newer verify starts, this one aborts
  const myToken = ++_verifyToken;
  update({ verifyStatus: "checking" });
  try {
    const jsQR  = await ensureJsQR();
    if (myToken !== _verifyToken) return; // stale â€” newer verify already running
    const ctx   = canvas.getContext("2d", { willReadFrequently: true });
    const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const res   = jsQR(idata.data, idata.width, idata.height, {
      inversionAttempts: "dontInvert" // B&W default â€” skip inversion, faster
    });
    if (myToken !== _verifyToken) return; // stale â€” newer verify finished first
    update({ verifyStatus: res?.data === expectedData ? "pass" : "fail" });
    if (res && res.data !== expectedData)
      console.warn("[QR v9.1] Mismatch\nExpected:", expectedData, "\nDecoded:", res.data);
  } catch {
    if (myToken === _verifyToken) update({ verifyStatus: null });
  }
}

/* â”€â”€ Friendly error messages for known qrcode-generator failures â”€â”€â”€ */
function friendlyQRError(msg) {
  if (!msg) return "QR generation failed";
  if (/code length overflow/i.test(msg)) return "Data too long for this error correction level â€” try L or M";
  if (/invalid/i.test(msg))             return "Invalid data for QR encoding";
  return "QR generation failed: " + msg;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   QRController v9.1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QRC = (() => {
  let _lastSig = null;

  function mount() { return document.getElementById("qr-mount"); }

  function sig(data, ec, hasMargin) {
    return [data, ec, hasMargin].join("|");
  }

  async function generate(opts) {
    const el = mount(); if (!el) return;
    const s  = sig(opts.data, opts.ecLevel, opts.hasMargin);
    if (s === _lastSig) return;
    _lastSig = s;

    // Monotonic generation token â€” any awaited code checks this before touching DOM
    const myToken = ++_genToken;

    update({ verifyStatus: "checking", hasQR: false });
    syncMount();

    try {
      // Try worker first â€” falls back to main thread silently
      let result;
      try {
        result = await qrViaWorker(opts.data, opts.ecLevel);
      } catch(workerErr) {
        // Worker failed â€” try main-thread fallback
        try {
          result = await qrFallback(opts.data, opts.ecLevel);
        } catch(fallbackErr) {
          // Both paths failed â€” surface a clear error
          if (myToken !== _genToken) return;
          toast("Cannot generate QR â€” network unavailable. Check connection and try again.", "er", 5000);
          update({ verifyStatus: null, hasQR: false, qrVersion: 1 });
          return;
        }
      }

      // Stale check â€” a newer generate() call already took over
      if (myToken !== _genToken) return;

      if (!result.ok) throw new Error(result.error);

      const { grid, mc, version } = result;
      update({ qrVersion: version });

      // HiDPI â€” render at device pixel ratio, capped at 3Ã—
      const dpr        = Math.min(window.devicePixelRatio || 1, 3);
      const canvasSize = Math.round(Math.max(360, 360 * dpr));

      const canvas = drawGrid(grid, mc, canvasSize, opts.hasMargin);

      if (myToken !== _genToken) return; // stale â€” don't touch DOM

      el.innerHTML = "";
      el.appendChild(canvas);
      update({ hasQR: true });

      // Verify â€” fast jsQR on the drawn canvas
      verifyWithJsQR(opts.data, canvas);

    } catch(e) {
      if (myToken !== _genToken) return;
      toast(friendlyQRError(e.message), "er");
      update({ verifyStatus: null, hasQR: false, qrVersion: 1 });
    }
  }

  function clear() {
    const el = mount(); if (!el) return;
    _lastSig = null; // reset so switching back to same type regenerates
    el.innerHTML = "";
    const hint = document.createElement("div"); hint.className = "empty-hint";
    const big  = document.createElement("div"); big.className  = "big"; big.textContent = "â–£";
    const txt  = document.createElement("div"); txt.className  = "txt"; txt.textContent = "Enter data to generate";
    hint.appendChild(big); hint.appendChild(txt); el.appendChild(hint);
    update({ verifyStatus: null, hasQR: false, qrVersion: 1 });
  }

  return { generate, clear };
})();

/* â”€â”€ Download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function dlQR() {
  const c = document.getElementById("qr-mount")?.querySelector("canvas");
  if (!c) { toast("Generate a QR first","wn"); return; }
  const a = document.createElement("a");
  a.href = c.toDataURL("image/png"); a.download = "qrcode.png"; a.click();
}

/* â”€â”€ Copy image â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function copyImg() {
  const c = document.getElementById("qr-mount")?.querySelector("canvas");
  if (!c) { toast("Generate a QR first","wn"); return; }
  c.toBlob(async blob => {
    try {
      await navigator.clipboard.write([new ClipboardItem({"image/png": blob})]);
      update({ imgCopied: true });
      setTimeout(() => update({ imgCopied: false }), 2000);
      toast("Image copied", "ok");
    } catch { toast("Clipboard unavailable â€” use Download","wn"); }
  });
}

/* â”€â”€ Copy data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function copyData(raw) {
  try {
    await navigator.clipboard.writeText(raw);
    update({ dataCopied: true });
    setTimeout(() => update({ dataCopied: false }), 2000);
    toast("Copied","ok");
  } catch { toast("Clipboard write failed","er"); }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QR_TYPES = [
  {id:"url",   label:"URL",   icon:"ğŸ”—"},
  {id:"text",  label:"Text",  icon:"ğŸ“"},
  {id:"email", label:"Email", icon:"âœ‰ï¸"},
  {id:"sms",   label:"SMS",   icon:"ğŸ’¬"},
  {id:"phone", label:"Phone", icon:"ğŸ“"},
  {id:"wifi",  label:"WiFi",  icon:"ğŸ“¶"},
  {id:"vcard", label:"vCard", icon:"ğŸ‘¤"},
];
const EC_LEVELS   = ["L","M","Q","H"];
const KNOWN_TYPES = new Set(QR_TYPES.map(t => t.id));

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   localStorage â€” type-safe, key-scoped
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function lsGet(k, fb) {
  try {
    const v = localStorage.getItem(k); if (!v) return fb;
    const p = JSON.parse(v);
    if (typeof p !== "object" || p === null || Array.isArray(p)) return fb;
    return p;
  } catch { return fb; }
}
function lsSet(k, v) {
  try { localStorage.setItem(k, JSON.stringify(v)); }
  catch(e) { if (e.name==="QuotaExceededError"||e.code===22) toast("Storage full","wn"); }
}
function lsSetFields(type, fields) {
  if (!KNOWN_TYPES.has(type)) return;
  lsSet("qrs_fields_"+type, fields);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE â€” 9 keys. Nothing more.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const S = {
  qrType:       "url",
  fields:       lsGet("qrs_fields_url", {}),
  fieldErrs:    {},
  ecLevel:      "H",
  hasMargin:    true,
  verifyStatus: null,
  hasQR:        false,
  qrVersion:    1,
  imgCopied:    false,
  dataCopied:   false,
};

let _raf = false;
function update(patch, afterRender) {
  Object.assign(S, typeof patch === "function" ? patch(S) : patch);
  if (!_raf) {
    _raf = true;
    requestAnimationFrame(() => {
      render();
      _raf = false;
      if (afterRender) afterRender();
    });
  }
}

/* â”€â”€ h() â€” zero innerHTML, safe DOM builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function h(tag, attrs={}, ...kids) {
  const el = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) {
    if (v === null || v === undefined || v === false) continue;
    if (k === "class")                          el.className = v;
    else if (k === "style" && typeof v==="object") Object.assign(el.style, v);
    else if (k === "value")                     el.value = v;
    else if (k === "checked")                   el.checked = !!v;
    else if (k === "selected")                  el.selected = !!v;
    else if (k === "disabled")                  el.disabled = !!v;
    else if (k.startsWith("on") && typeof v==="function")
      el.addEventListener(k.slice(2).toLowerCase(), v);
    else el.setAttribute(k, v);
  }
  for (const c of kids.flat(Infinity)) {
    if (c == null || c === false || c === true) continue;
    if (typeof c === "string" || typeof c === "number")
      el.appendChild(document.createTextNode(String(c)));
    else if (c instanceof Node) el.appendChild(c);
  }
  return el;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PERSISTENT DOM â€” never replaced by render()
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QR_MOUNT = (() => {
  const el   = document.createElement("div"); el.id = "qr-mount"; el.className = "qr-mount empty";
  const hint = document.createElement("div"); hint.className = "empty-hint";
  const big  = document.createElement("div"); big.className  = "big"; big.textContent = "â–£";
  const txt  = document.createElement("div"); txt.className  = "txt"; txt.textContent = "Enter data to generate";
  hint.appendChild(big); hint.appendChild(txt); el.appendChild(hint);
  return el;
})();

const FORM_EL = document.createElement("div"); FORM_EL.id = "form-container";

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FORM PATCHING â€” cursor-safe, in-place updates, no focus loss
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function patchInput(container, key, label, placeholder, type="text") {
  let wrap = container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap = document.createElement("div"); wrap.className="fld"; wrap.setAttribute("data-key",key);
    const lbl = document.createElement("div"); lbl.className="lbl"; lbl.textContent=label;
    const inp = document.createElement("input"); inp.type=type; inp.placeholder=placeholder;
    const err = document.createElement("div"); err.className="fld-err";
    inp.addEventListener("input", e => {
      const nf = {...S.fields, [key]: e.target.value};
      const errs = validateFields(S.qrType, nf);
      update({fields:nf, fieldErrs:errs});
      lsSetFields(S.qrType, nf);
      scheduleQR(); // reads S.fields â€” always current after update()
    });
    wrap.appendChild(lbl); wrap.appendChild(inp); wrap.appendChild(err);
    container.appendChild(wrap);
  }
  const inp = wrap.querySelector("input");
  const err = wrap.querySelector(".fld-err");
  if (document.activeElement !== inp && inp.value !== (S.fields[key]||""))
    inp.value = S.fields[key]||"";
  inp.type = type; inp.placeholder = placeholder;
  wrap.querySelector(".lbl").textContent = label;
  const msg = S.fieldErrs[key];
  if (msg) { inp.classList.add("err"); err.textContent=msg; err.classList.add("show"); }
  else     { inp.classList.remove("err"); err.textContent=""; err.classList.remove("show"); }
}

function patchTextarea(container, key, label, placeholder) {
  let wrap = container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap = document.createElement("div"); wrap.className="fld"; wrap.setAttribute("data-key",key);
    const lbl = document.createElement("div"); lbl.className="lbl"; lbl.textContent=label;
    const ta  = document.createElement("textarea"); ta.placeholder=placeholder;
    ta.addEventListener("input", e => {
      const nf = {...S.fields, [key]: e.target.value};
      update({fields:nf}); lsSetFields(S.qrType, nf); scheduleQR();
    });
    wrap.appendChild(lbl); wrap.appendChild(ta); container.appendChild(wrap);
  }
  const ta = wrap.querySelector("textarea");
  if (document.activeElement !== ta && ta.value !== (S.fields[key]||""))
    ta.value = S.fields[key]||"";
  ta.placeholder = placeholder;
}

function patchSelect(container, key, label, options) {
  let wrap = container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap = document.createElement("div"); wrap.className="fld"; wrap.setAttribute("data-key",key);
    const lbl = document.createElement("div"); lbl.className="lbl"; lbl.textContent=label;
    const sel = document.createElement("select");
    options.forEach(o => {
      const op = document.createElement("option"); op.value=o; op.textContent=o;
      sel.appendChild(op);
    });
    sel.addEventListener("change", e => {
      const nf = {...S.fields, [key]: e.target.value};
      update({fields:nf}); lsSetFields(S.qrType, nf); scheduleQR();
    });
    wrap.appendChild(lbl); wrap.appendChild(sel); container.appendChild(wrap);
  }
  wrap.querySelector("select").value = S.fields[key]||options[0];
}

function buildForm(container) {
  const needed = getNeededKeys(S.qrType);
  [...container.querySelectorAll("[data-key]")].forEach(el => {
    if (!needed.includes(el.dataset.key)) el.remove();
  });
  if (S.qrType !== "vcard") {
    const tc = container.querySelector(".two"); if (tc) tc.remove();
  }
  switch(S.qrType) {
    case "url":   patchInput(container,"url","Website URL","https://example.com","url"); break;
    case "text":  patchTextarea(container,"text","Text Content","Any text, code, messageâ€¦"); break;
    case "email":
      patchInput(container,"email","Email","you@example.com","email");
      patchInput(container,"subject","Subject","Subject line");
      patchTextarea(container,"body","Body","Messageâ€¦"); break;
    case "sms":
      patchInput(container,"phone","Phone Number","+1 555 000 0000","tel");
      patchTextarea(container,"message","Message","SMS bodyâ€¦"); break;
    case "phone": patchInput(container,"phone","Phone Number","+1 555 000 0000","tel"); break;
    case "wifi":
      patchInput(container,"ssid","Network SSID","MyWiFiNetwork");
      patchInput(container,"password","Password","WiFi password","password");
      patchSelect(container,"security","Security",["WPA","WPA2","WEP","None"]); break;
    case "vcard": {
      let tc = container.querySelector(".two");
      if (!tc) {
        tc = document.createElement("div"); tc.className="two";
        container.insertBefore(tc, container.firstChild);
      }
      [...tc.querySelectorAll("[data-key]")].forEach(el => {
        if (!["firstName","lastName"].includes(el.dataset.key)) el.remove();
      });
      patchInput(tc,"firstName","First Name","John");
      patchInput(tc,"lastName","Last Name","Doe");
      patchInput(container,"org","Organization","Company Name");
      patchInput(container,"phone","Phone","+1 555 000 0000","tel");
      patchInput(container,"email","Email","john@example.com","email");
      patchInput(container,"website","Website","https://example.com","url");
      patchInput(container,"address","Address","123 Main St, City");
      break;
    }
  }
}

function getNeededKeys(type) {
  return {
    url:   ["url"],
    text:  ["text"],
    email: ["email","subject","body"],
    sms:   ["phone","message"],
    phone: ["phone"],
    wifi:  ["ssid","password","security"],
    vcard: ["firstName","lastName","org","phone","email","website","address"]
  }[type]||[];
}

/* â”€â”€ QR scheduling â€” 180ms debounce â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _qrTimer = null;
function scheduleQR() {
  if (_qrTimer) clearTimeout(_qrTimer);
  _qrTimer = setTimeout(() => triggerQR(), 180);
}
function triggerQR() {
  // Always read S.fields â€” never accept a passed argument that may be stale
  // from a previous debounce cycle when multiple fields fired in rapid succession
  _qrTimer = null;
  const f    = S.fields;
  const errs = validateFields(S.qrType, f);
  if (Object.keys(errs).length) { QRC.clear(); return; }
  const raw  = buildData(S.qrType, f);
  if (!raw.trim()) { QRC.clear(); return; }
  QRC.generate({ data: raw, ecLevel: S.ecLevel, hasMargin: S.hasMargin });
}

/* â”€â”€ syncMount: cheap QR_MOUNT class/scanline sync â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function syncMount(hasData) {
  const hd = hasData !== undefined ? hasData : !!buildData(S.qrType, S.fields).trim();
  QR_MOUNT.className =
    (!hd ? "qr-mount empty" : "qr-mount") +
    (S.verifyStatus==="pass" ? " pass" : S.verifyStatus==="fail" ? " fail" : "");

  let sl = QR_MOUNT.querySelector(".scanline-wrap");
  if (S.verifyStatus==="checking") {
    if (!sl) {
      sl = document.createElement("div"); sl.className="scanline-wrap";
      const ln = document.createElement("div"); ln.className="scanline";
      sl.appendChild(ln); QR_MOUNT.appendChild(sl);
    }
  } else { if (sl) sl.remove(); }

  let hint = QR_MOUNT.querySelector(".empty-hint");
  if (!hd) {
    if (!hint) {
      hint = document.createElement("div"); hint.className="empty-hint";
      const big = document.createElement("div"); big.className="big"; big.textContent="â–£";
      const txt = document.createElement("div"); txt.className="txt"; txt.textContent="Enter data to generate";
      hint.appendChild(big); hint.appendChild(txt); QR_MOUNT.appendChild(hint);
    }
  } else { if (hint) hint.remove(); }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RENDER â€” UI components
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const tog = (on, onClick) =>
  h("button",{class:"tog"+(on?" on":""),onClick}, h("div",{class:"tog-k"}));

function rHeader() {
  return h("header",{},
    h("div",{class:"hdr-inner"},
      h("div",{class:"logo"},
        h("div",{class:"logo-box"},"â–£"),
        h("div",{class:"logo-name"},"QR",h("span",{},"_"),"studio")
      ),
      h("div",{class:"hdr-badges"},
        h("div",{class:"hdr-badge v9"},"v9.1"),
        h("div",{class:"hdr-badge"},"ENCODE")
      )
    )
  );
}

function rTypeSelector() {
  return h("div",{},
    h("div",{class:"sec-label",style:"margin-bottom:12px"},"â—ˆ Content Type"),
    h("div",{class:"type-grid"},
      QR_TYPES.map(t => h("button",{
        class:"type-btn"+(S.qrType===t.id?" on":""),
        onClick: () => {
          if (S.qrType===t.id) return;
          const saved = lsGet("qrs_fields_"+t.id, {});
          const errs  = validateFields(t.id, saved);
          update({qrType:t.id, fields:saved, fieldErrs:errs}, () => {
            buildForm(FORM_EL); triggerQR();
          });
        }
      }, h("span",{class:"ico"},t.icon), t.label))
    )
  );
}

/* Settings: EC + quiet zone only. Clean. */
function rSettings() {
  return h("div",{class:"sec"},
    h("div",{class:"sec-label"},"â—ˆ Settings"),

    h("div",{class:"lbl"},"Error Correction"),
    h("div",{class:"ec-row"},
      EC_LEVELS.map(l => h("button",{
        class: "ecb"+(S.ecLevel===l?" on":""),
        title: {L:"7% recovery â€” smallest QR",M:"15% recovery",Q:"25% recovery",H:"30% recovery â€” largest QR, most reliable"}[l],
        onClick: () => { update({ecLevel:l}); triggerQR(); }
      }, l))
    ),

    h("div",{class:"tog-row"},
      tog(S.hasMargin, () => { update({hasMargin:!S.hasMargin}); triggerQR(); }),
      h("span",{
        class:"tog-lbl",
        onClick: () => { update({hasMargin:!S.hasMargin}); triggerQR(); }
      },"Quiet zone margin")
    )
  );
}

/* Stats bar: version, capacity, bytes, EC â€” nothing more */
function rQRStats(rawData) {
  if (!S.hasQR || !rawData.trim()) return null;
  const byteLen = new TextEncoder().encode(rawData).length;
  const maxCap  = QR_CAP[S.ecLevel]?.[S.qrVersion-1] || 0;
  const pct     = maxCap ? Math.round(byteLen/maxCap*100) : 0;
  const vCl     = S.qrVersion > 25 ? "bad" : S.qrVersion > 15 ? "warn" : "";
  const pCl     = pct > 90 ? "bad" : pct > 70 ? "warn" : "";

  const wrap = document.createElement("div"); wrap.className = "qr-stats";
  [
    h("div",{class:`stat-chip ${vCl}`},    "v",   h("span",{class:"sv"}, S.qrVersion)),
    h("div",{class:`stat-chip ${pCl}`},    "cap ", h("span",{class:"sv"}, pct+"%")),
    h("div",{class:"stat-chip"},           "bytes ",h("span",{class:"sv"}, byteLen)),
    h("div",{class:"stat-chip"},           h("span",{class:"sv"}, S.ecLevel)," EC"),
  ].forEach(c => wrap.appendChild(c));
  return wrap;
}

/* Preview panel */
function rPreviewPanel(rawData) {
  const hasData = !!rawData.trim();
  syncMount(hasData);

  const stats = rQRStats(rawData);

  return h("div",{class:"sec"},
    h("div",{class:"prev-hdr"},
      h("div",{class:"prev-title"},"â—ˆ Preview"),
      null // verify badge injected by updateVerifyBadge()
    ),
    h("div",{id:"qr-mount-slot"}),
    stats,
    S.hasQR && hasData ? h("div",{},
      h("div",{class:"dl-row"},
        h("button",{class:"btn-main",onClick:dlQR},"â¬‡ Download PNG")
      ),
      h("div",{class:"cp-row"},
        h("button",{
          class:"btn-g"+(S.imgCopied?" done":""),
          onClick:copyImg
        }, S.imgCopied?"âœ“ Copied!":"â˜ Copy Image"),
        h("button",{
          class:"btn-g"+(S.dataCopied?" done":""),
          onClick:()=>copyData(rawData)
        }, S.dataCopied?"âœ“ Copied!":"â˜ Copy Data")
      )
    ) : null
  );
}

/* â”€â”€ Main render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _prevSig = null;
function render() {
  const root = document.getElementById("root"); if (!root) return;

  const rawData = buildData(S.qrType, S.fields);
  const hasData = !!rawData.trim();

  const sig = [
    S.qrType, S.ecLevel, S.hasMargin,
    hasData, S.hasQR, S.qrVersion,
    S.imgCopied, S.dataCopied,
    Object.keys(S.fieldErrs).join(",")
  ].join("|");

  // Always sync mount (cheap)
  syncMount(hasData);

  if (sig === _prevSig) return;
  _prevSig = sig;

  // Full rebuild
  const tree = document.createElement("div");
  tree.appendChild(rHeader());

  const main = document.createElement("div"); main.className = "main";
  const grid = document.createElement("div"); grid.className = "grid";

  // Left column
  const left = document.createElement("div");

  const typeSec = document.createElement("div"); typeSec.className = "sec";
  typeSec.appendChild(rTypeSelector()); left.appendChild(typeSec);

  const formSec = document.createElement("div"); formSec.className = "sec";
  formSec.style.marginTop = "14px";
  const fl = document.createElement("div"); fl.className = "sec-label"; fl.textContent = "â—ˆ Content";
  formSec.appendChild(fl); formSec.appendChild(FORM_EL); left.appendChild(formSec);

  left.appendChild(rSettings());
  grid.appendChild(left);

  // Right column
  const right = document.createElement("div"); right.className = "preview-wrap";
  right.appendChild(rPreviewPanel(rawData));
  grid.appendChild(right);

  main.appendChild(grid);
  tree.appendChild(main);

  root.innerHTML = "";
  while (tree.firstChild) root.appendChild(tree.firstChild);

  // Re-attach persistent elements
  const slot = document.getElementById("qr-mount-slot");
  if (slot) slot.replaceWith(QR_MOUNT);

  buildForm(FORM_EL);
  updateVerifyBadge();
}

/* â”€â”€ Verify badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function updateVerifyBadge() {
  const hdr = document.querySelector(".prev-hdr"); if (!hdr) return;
  let badge = hdr.querySelector(".vbadge");
  if (!S.verifyStatus) { if (badge) badge.remove(); return; }
  if (!badge) { badge = document.createElement("span"); hdr.appendChild(badge); }

  const map = {
    checking: ["vbadge checking", "âŸ³ verifyingâ€¦"],
    pass:     ["vbadge pass",     "âœ“ verified"],
    fail:     ["vbadge fail",     "âš  failed"],
  };
  const [cls, txt] = map[S.verifyStatus] || ["vbadge",""];
  badge.className = cls;
  badge.textContent = txt;
}

/* â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
render();
buildForm(FORM_EL);
if (Object.keys(S.fields).length > 0) triggerQR();
</script>
</body>
</html>
