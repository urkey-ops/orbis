<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>QR_studio v7</title>
<meta http-equiv="Content-Security-Policy"
  content="default-src 'self';
           script-src 'unsafe-inline' https://unpkg.com https://cdnjs.cloudflare.com;
           style-src 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com;
           font-src https://fonts.gstatic.com;
           img-src 'self' data: blob:;
           connect-src 'none';">
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://unpkg.com"/>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;500;600;700;800&display=swap"/>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --a:#b8f400;
  --a10:rgba(184,244,0,.10);
  --a20:rgba(184,244,0,.20);
  --dark:#090b08;
  --card:#0f1210;
  --bord:rgba(184,244,0,.09);
  --bord2:rgba(255,255,255,.06);
  --mut:rgba(255,255,255,.30);
  --danger:#ff4455;
  --warn:#ffa040;
}
html{scroll-behavior:smooth}
body{background:var(--dark);color:#e4ebe0;font-family:'Syne',sans-serif;min-height:100vh;overflow-x:hidden}
::-webkit-scrollbar{width:3px}
::-webkit-scrollbar-thumb{background:var(--bord);border-radius:2px}

input,textarea,select{
  font-family:inherit;background:rgba(255,255,255,.025);
  border:1px solid var(--bord2);border-radius:8px;
  color:#e4ebe0;padding:9px 12px;font-size:14px;width:100%;
  outline:none;transition:border-color .15s,box-shadow .15s;
}
input:focus,textarea:focus,select:focus{border-color:var(--a);box-shadow:0 0 0 3px rgba(184,244,0,.06)}
input::placeholder,textarea::placeholder{color:rgba(255,255,255,.16)}
option{background:#141a12}
textarea{resize:vertical;min-height:68px}
button{cursor:pointer;font-family:inherit;border:none;transition:all .15s}
button:active{transform:scale(.96)}
input[type=range]{padding:0;background:none;border:none;accent-color:var(--a);cursor:pointer;height:4px}
input[type=range]:focus{box-shadow:none;border:none}
input[type=color]{padding:2px;border:none;background:none;cursor:pointer;width:100%;height:100%}
input.err{border-color:rgba(255,68,85,.5)!important;box-shadow:0 0 0 3px rgba(255,68,85,.06)!important}

@keyframes toastIn{from{opacity:0;transform:translateX(28px)}to{opacity:1;transform:none}}
@keyframes scanline{0%{top:-4px}100%{top:calc(100% + 4px)}}

/* â”€â”€ layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
header{
  position:sticky;top:0;z-index:100;
  border-bottom:1px solid var(--bord);
  background:rgba(9,11,8,.92);
  backdrop-filter:blur(20px);
  padding:0 24px;
}
.hdr-inner{max-width:1100px;margin:0 auto;height:54px;display:flex;align-items:center;justify-content:space-between}
.logo{display:flex;align-items:center;gap:9px}
.logo-box{width:28px;height:28px;background:var(--a);border-radius:6px;display:grid;place-items:center;font-size:13px;flex-shrink:0}
.logo-name{font-family:'Space Mono',monospace;font-weight:700;font-size:16px;letter-spacing:-1px;color:#e4ebe0}
.logo-name span{color:var(--a)}
.hdr-badges{display:flex;gap:6px;align-items:center}
.hdr-badge{font-family:'Space Mono',monospace;font-size:10px;color:rgba(184,244,0,.45);letter-spacing:2px;border:1px solid var(--bord);padding:4px 10px;border-radius:20px}
.hdr-badge.v7{color:rgba(255,160,64,.7);border-color:rgba(255,160,64,.25)}

.main{max-width:1100px;margin:0 auto;padding:24px 24px 60px}
.grid{display:grid;grid-template-columns:1fr 390px;gap:16px;align-items:start}
@media(max-width:860px){.grid{grid-template-columns:1fr}}

.sec{background:var(--card);border:1px solid var(--bord);border-radius:14px;padding:20px}
.sec+.sec{margin-top:14px}
.sec-label{font-family:'Space Mono',monospace;font-size:9px;font-weight:700;color:rgba(184,244,0,.38);letter-spacing:3px;text-transform:uppercase;margin-bottom:16px}

/* â”€â”€ type selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.type-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:5px}
@media(max-width:600px){.type-grid{grid-template-columns:repeat(4,1fr)}}
.type-btn{display:flex;flex-direction:column;align-items:center;gap:4px;padding:8px 4px;border-radius:9px;border:1px solid var(--bord2);background:transparent;color:var(--mut);font-size:11px;font-weight:600}
.type-btn .ico{font-size:16px}
.type-btn.on{border-color:var(--a);background:var(--a10);color:var(--a)}
.type-btn:hover:not(.on){border-color:rgba(255,255,255,.12);color:rgba(255,255,255,.6)}

/* â”€â”€ form â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.lbl{font-family:'Space Mono',monospace;font-size:10px;font-weight:700;color:rgba(255,255,255,.24);letter-spacing:1.5px;text-transform:uppercase;margin-bottom:5px}
.fld{margin-bottom:12px}
.fld:last-child{margin-bottom:0}
.fld-err{font-size:10px;color:var(--danger);font-family:'Space Mono',monospace;margin-top:3px;display:none}
.fld-err.show{display:block}
.two{display:grid;grid-template-columns:1fr 1fr;gap:10px}

/* â”€â”€ customize tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.ctabs{display:flex;gap:2px;background:rgba(255,255,255,.025);border:1px solid rgba(255,255,255,.05);border-radius:8px;padding:3px;margin-bottom:16px}
.ctab{flex:1;padding:6px 0;border-radius:6px;border:none;font-family:'Space Mono',monospace;font-size:10px;font-weight:700;background:transparent;color:rgba(255,255,255,.26);text-transform:uppercase;letter-spacing:1px}
.ctab.on{background:var(--a);color:var(--dark)}

/* â”€â”€ style buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.opt-grid{display:grid;gap:6px;margin-bottom:14px}
.opt-grid.cols3{grid-template-columns:repeat(3,1fr)}
.opt-grid.cols3b{grid-template-columns:repeat(3,1fr)}
.opt-btn{padding:9px 5px;border-radius:9px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-size:11px;font-weight:600;text-align:center}
.opt-btn.on{border-color:var(--a);background:var(--a10);color:var(--a)}
.opt-btn:hover:not(.on){border-color:rgba(255,255,255,.14);color:rgba(255,255,255,.6)}

/* â”€â”€ colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tpl-row{display:flex;gap:5px;flex-wrap:wrap;margin-bottom:14px}
.tpl{display:flex;align-items:center;gap:5px;padding:5px 10px;border-radius:7px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.4);font-size:11px;font-weight:600}
.tpl:hover{border-color:rgba(255,255,255,.18)}
.c-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
.c-lbl{font-size:13px;color:var(--mut)}
.c-ctrl{display:flex;align-items:center;gap:7px}
.swatch{width:28px;height:28px;border-radius:5px;border:2px solid rgba(255,255,255,.1);position:relative;overflow:hidden;cursor:pointer;flex-shrink:0}
.hex{width:82px;font-size:12px;font-family:'Space Mono',monospace;padding:4px 7px}

/* â”€â”€ toggles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tog-row{display:flex;align-items:center;gap:9px;margin-bottom:10px}
.tog{width:34px;height:18px;border-radius:9px;background:rgba(255,255,255,.08);position:relative;cursor:pointer;transition:background .18s;flex-shrink:0;border:none;padding:0;display:block}
.tog.on{background:var(--a)}
.tog-k{position:absolute;top:2px;left:2px;width:14px;height:14px;border-radius:50%;background:#fff;transition:left .18s;pointer-events:none}
.tog.on .tog-k{left:18px}
.tog-lbl{font-size:13px;color:var(--mut);cursor:pointer;user-select:none}

/* â”€â”€ advanced â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.ec-row{display:flex;gap:6px;margin-bottom:5px}
.ecb{flex:1;padding:8px 0;border-radius:7px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-weight:700;font-size:13px;font-family:'Space Mono',monospace}
.ecb.on{border-color:var(--a);background:var(--a);color:var(--dark)}
.ecb.clamped{border-color:rgba(184,244,0,.4);color:var(--a)}
.ec-hint{font-size:10px;color:rgba(255,255,255,.16);font-family:'Space Mono',monospace;margin-bottom:18px;line-height:1.6}

.logo-up{width:100%;padding:16px;border-radius:9px;background:var(--a10);cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:6px;color:var(--a);outline:2px dashed var(--bord);border:none}
.logo-up:hover{background:var(--a20)}
.logo-prev{display:flex;align-items:center;gap:10px;margin-bottom:14px}
.logo-img{width:44px;height:44px;object-fit:contain;border-radius:7px;border:1px solid rgba(255,255,255,.08);background:#fff}
.logo-rm{width:26px;height:26px;border-radius:5px;border:none;background:rgba(255,68,85,.12);color:var(--danger);display:grid;place-items:center;font-size:16px;flex-shrink:0}

.notice{margin-top:10px;padding:8px 10px;border-radius:7px;background:rgba(184,244,0,.04);border:1px solid var(--bord);font-size:11px;color:rgba(255,255,255,.3);line-height:1.6}
.notice strong{color:rgba(184,244,0,.6);font-weight:600}
.notice.warn{background:rgba(255,160,64,.05);border-color:rgba(255,160,64,.2);color:rgba(255,160,64,.75)}
.notice.warn strong{color:var(--warn)}

/* â”€â”€ scan status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.scan-box{margin-top:14px;padding:13px 15px;border-radius:9px;border:1px solid}
.scan-box.good{border-color:rgba(184,244,0,.22);background:rgba(184,244,0,.04)}
.scan-box.caution{border-color:rgba(255,160,64,.22);background:rgba(255,160,64,.04)}
.scan-box.bad{border-color:rgba(255,68,85,.22);background:rgba(255,68,85,.04)}
.scan-hdr{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.scan-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.scan-title{font-family:'Space Mono',monospace;font-size:10px;font-weight:700;letter-spacing:1px}
.scan-items{display:flex;flex-direction:column;gap:4px}
.scan-item{font-size:11px;color:rgba(255,255,255,.36);display:flex;align-items:flex-start;gap:6px;line-height:1.5}

/* â”€â”€ print DPI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.dpi-wrap{margin-top:14px;padding:12px;border-radius:9px;background:rgba(255,255,255,.018);border:1px solid var(--bord2)}
.dpi-title{font-family:'Space Mono',monospace;font-size:9px;font-weight:700;color:rgba(255,255,255,.22);letter-spacing:2px;text-transform:uppercase;margin-bottom:10px}
.dpi-row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
.dpi-result{padding:8px 10px;border-radius:7px;font-size:11px;font-family:'Space Mono',monospace;line-height:1.6}
.dpi-result.ok{background:var(--a10);border:1px solid var(--bord);color:rgba(184,244,0,.7)}
.dpi-result.warn{background:rgba(255,160,64,.06);border:1px solid rgba(255,160,64,.2);color:rgba(255,160,64,.8)}
.dpi-result.bad{background:rgba(255,68,85,.06);border:1px solid rgba(255,68,85,.2);color:rgba(255,68,85,.8)}
.dpi-result.empty{color:rgba(255,255,255,.2);font-size:10px}

/* â”€â”€ preview panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.preview-wrap{position:sticky;top:68px}
.prev-hdr{display:flex;align-items:center;justify-content:space-between;margin-bottom:14px}
.prev-title{font-family:'Space Mono',monospace;font-size:9px;font-weight:700;color:rgba(184,244,0,.38);letter-spacing:3px;text-transform:uppercase}

#qr-mount{
  display:flex;justify-content:center;align-items:center;
  min-height:280px;border-radius:11px;overflow:hidden;
  width:min(380px,100%);margin:0 auto 14px;
  transition:box-shadow .25s,background .25s;
  position:relative;
}
#qr-mount.empty{background:rgba(255,255,255,.018);outline:2px dashed var(--bord)}
#qr-mount.pass{box-shadow:0 0 0 2px var(--a),0 0 32px rgba(184,244,0,.10)}
#qr-mount.fail{box-shadow:0 0 0 2px var(--danger),0 0 32px rgba(255,68,85,.08)}
#qr-mount canvas{width:100% !important;height:auto !important;display:block}

.scanline-wrap{position:absolute;inset:0;pointer-events:none;overflow:hidden;border-radius:11px}
.scanline{position:absolute;left:0;right:0;height:2px;background:linear-gradient(90deg,transparent,var(--a),transparent);animation:scanline 1.2s ease-in-out infinite;opacity:.7}

#qr-mount.lowlight canvas{filter:brightness(0.25) saturate(0.15) contrast(1.15)}

.empty-hint{text-align:center;color:rgba(184,244,0,.16);pointer-events:none}
.empty-hint .big{font-size:48px;margin-bottom:10px;filter:grayscale(1)}
.empty-hint .txt{font-size:11px;font-family:'Space Mono',monospace;letter-spacing:1px}

/* â”€â”€ verify badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.vbadge{font-size:10px;font-family:'Space Mono',monospace;display:flex;align-items:center;gap:5px;white-space:nowrap}
.vbadge.pass{color:var(--a)}
.vbadge.fail{color:var(--danger)}
.vbadge.loading,.vbadge.checking{color:rgba(255,255,255,.25)}

/* â”€â”€ stats bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.qr-stats{display:flex;gap:5px;flex-wrap:wrap;margin-bottom:12px}
.stat-chip{padding:3px 8px;border-radius:5px;background:rgba(255,255,255,.025);border:1px solid rgba(255,255,255,.05);font-family:'Space Mono',monospace;font-size:10px;color:rgba(255,255,255,.28);display:flex;align-items:center;gap:4px}
.stat-chip .sv{color:rgba(184,244,0,.7);font-weight:700}
.stat-chip.warn .sv{color:var(--warn)}
.stat-chip.bad .sv{color:var(--danger)}

/* â”€â”€ actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.dl-row{display:flex;gap:7px;margin-bottom:7px}
.btn-main{flex:1;padding:10px 0;border-radius:9px;border:none;background:var(--a);color:var(--dark);font-weight:700;font-size:13px;font-family:'Syne',sans-serif}
.btn-main:hover{background:#cbff1a}
.cp-row{display:flex;gap:7px;margin-bottom:7px}
.btn-g{flex:1;padding:8px 0;border-radius:9px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-size:12px;font-weight:600}
.btn-g.done{background:var(--a10);color:var(--a);border-color:var(--bord)}
.data-chip{padding:8px 10px;border-radius:7px;background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.05);font-size:10px;font-family:'Space Mono',monospace;color:rgba(255,255,255,.2);word-break:break-all;max-height:52px;overflow-y:auto;line-height:1.6;margin-bottom:7px}
.cam-tip{padding:9px 12px;border-radius:8px;border:1px solid var(--bord);background:var(--a10);font-size:11px;color:rgba(184,244,0,.55);font-family:'Space Mono',monospace;line-height:1.6;text-align:center}
.btn-ll{padding:8px 0;border-radius:9px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-size:11px;font-weight:700;font-family:'Space Mono',monospace;width:100%;margin-bottom:7px}
.btn-ll.on{border-color:rgba(255,160,64,.4);background:rgba(255,160,64,.06);color:var(--warn)}

/* â”€â”€ batch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.batch-drop{width:100%;padding:20px;border-radius:9px;background:rgba(184,244,0,.03);outline:2px dashed rgba(184,244,0,.15);border:none;display:flex;flex-direction:column;align-items:center;gap:6px;color:rgba(184,244,0,.5);cursor:pointer}
.batch-drop:hover{background:var(--a10);outline-color:rgba(184,244,0,.3)}
.batch-drop .ico{font-size:24px}
.batch-drop .txt{font-size:12px;font-family:'Space Mono',monospace}
.batch-drop .sub{font-size:10px;color:rgba(255,255,255,.2)}
.batch-progress{margin-top:12px;padding:12px;border-radius:9px;background:rgba(255,255,255,.02);border:1px solid var(--bord2)}
.batch-bar-wrap{height:4px;border-radius:2px;background:rgba(255,255,255,.06);overflow:hidden;margin:8px 0}
.batch-bar{height:100%;background:var(--a);border-radius:2px;transition:width .15s}
.batch-txt{font-family:'Space Mono',monospace;font-size:10px;color:rgba(255,255,255,.3)}
.batch-dl{width:100%;margin-top:10px;padding:9px;border-radius:8px;border:none;background:var(--a);color:var(--dark);font-weight:700;font-size:12px;font-family:'Syne',sans-serif}

/* â”€â”€ toasts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#toasts{position:fixed;top:66px;right:18px;z-index:9999;display:flex;flex-direction:column;gap:7px;pointer-events:none}
.toast{padding:10px 15px;border-radius:10px;font-size:12px;font-weight:600;animation:toastIn .2s ease;display:flex;align-items:center;gap:7px;backdrop-filter:blur(16px);pointer-events:all}
.toast.ok{background:rgba(184,244,0,.13);border:1px solid rgba(184,244,0,.22);color:var(--a)}
.toast.er{background:rgba(255,68,85,.13);border:1px solid rgba(255,68,85,.22);color:var(--danger)}
.toast.wn{background:rgba(255,160,64,.13);border:1px solid rgba(255,160,64,.22);color:var(--warn)}
</style>
</head>
<body>
<div id="root"></div>
<div id="toasts"></div>
<script>
"use strict";
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   QR STUDIO v7 â€” Rock-solid. Industry-leading. Cross-verified.

   Architecture:
   â€¢ qrcode-generator@1.4.4 â€” exposes isDark(row,col), ~14KB, zero Node.js confusion
   â€¢ Native canvas renderer â€” custom dot/eye drawing via isDark(), overdraw pattern
   â€¢ DUAL CANVAS â€” display canvas (styled, HiDPI) + verify canvas (square, B&W, hidden)
   â€¢ ZXing MultiFormatReader + BinaryBitmap â€” zero PNG round-trip verify
   â€¢ Batch via qrcode-generator + JSZip â€” consistent with main path
   â€¢ No qr-code-styling dependency at all
   â€¢ Prefetch warmup strategy â€” no preload warnings
   â€¢ Gradient removed â€” conflicts with phone-camera-first mission
   â€¢ All v6 security hardening retained (S1â€“S20)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€ Allowed CDN origins â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const ALLOWED_ORIGINS = ["https://unpkg.com","https://cdnjs.cloudflare.com"];
function isSafeScriptSrc(src) {
  try { const u = new URL(src); return ALLOWED_ORIGINS.some(o => u.origin === new URL(o).origin); }
  catch { return false; }
}

/* â”€â”€ Script loader (deduplicated, origin-allowlisted) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const _sc = new Map();
function loadScript(src) {
  if (!isSafeScriptSrc(src)) return Promise.reject(new Error("Blocked: " + src));
  if (_sc.has(src)) return _sc.get(src);
  const p = new Promise((ok, fail) => {
    const s = document.createElement("script");
    s.src = src; s.onload = ok;
    s.onerror = () => { _sc.delete(src); fail(new Error("Load failed: " + src)); };
    document.head.appendChild(s);
  });
  _sc.set(src, p); return p;
}

/* â”€â”€ qrcode-generator: exposes isDark(row, col) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
// The only QR matrix library with a proper browser-safe isDark() API
let _qrgP = null;
function ensureQRG() {
  if (!_qrgP) _qrgP = loadScript("https://unpkg.com/qrcode-generator@1.4.4/qrcode.js")
    .then(() => {
      if (typeof window.qrcode !== "function") throw new Error("qrcode-generator not found");
      return window.qrcode;
    });
  return _qrgP;
}

/* â”€â”€ ZXing: verify only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _zxP = null;
function ensureZXing() {
  if (!_zxP) _zxP = loadScript("https://unpkg.com/@zxing/library@0.19.1/umd/index.min.js")
    .then(() => { if (!window.ZXing) throw new Error("ZXing unavailable"); return window.ZXing; })
    .catch(e => { _zxP = null; throw e; });
  return _zxP;
}

/* â”€â”€ JSZip: batch only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _zipP = null;
function ensureJSZip() {
  if (!_zipP) _zipP = loadScript("https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js")
    .then(() => { if (!window.JSZip) throw new Error("JSZip not found"); return window.JSZip; });
  return _zipP;
}

/* â”€â”€ Warmup: prefetch libs after page load â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
// No <link rel="preload"> â€” use JS warmup to avoid preload warnings
window.addEventListener("load", () => {
  ensureQRG().catch(() => {}); // warm qrcode-generator immediately after load
  setTimeout(() => ensureZXing().catch(() => {}), 1500); // ZXing 1.5s later
});

/* â”€â”€ Toast (textContent only â€” no innerHTML) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function toast(msg, type = "ok", ms = 2800) {
  const c = document.getElementById("toasts");
  const el = document.createElement("div"); el.className = "toast " + type;
  const ico = document.createElement("span"); ico.textContent = {ok:"âœ“",er:"âœ•",wn:"âš "}[type]||"â€¢";
  const tx = document.createElement("span"); tx.textContent = msg;
  el.appendChild(ico); el.appendChild(tx); c.appendChild(el);
  setTimeout(() => { el.style.cssText="opacity:0;transform:translateX(28px);transition:.18s"; setTimeout(()=>el.remove(),220); }, ms);
}

/* â”€â”€ Hex sanitizer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function safeHex(val, fallback="#000000") {
  if (!val) return fallback;
  let h = val.trim().replace(/^#/,"");
  if (h.length === 3) h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2];
  return /^[0-9a-fA-F]{6}$/.test(h) ? "#"+h : fallback;
}

/* â”€â”€ Image data URI validator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function isSafeImageDataURI(src) {
  return typeof src === "string" &&
    /^data:image\/(png|jpeg|gif|webp);base64,[A-Za-z0-9+/=]+$/.test(src);
}

/* â”€â”€ Field length caps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const MAX_URL  = 2048;
const MAX_TEXT = 2953; // QR v40 H absolute max bytes
const MAX_FIELD = 500;
const BATCH_MAX_ROWS = 500;
const BATCH_MAX_BYTES = 5 * 1024 * 1024;

function capField(val, max) {
  if (typeof val !== "string") return "";
  const enc = new TextEncoder().encode(val);
  if (enc.length <= max) return val;
  return new TextDecoder().decode(enc.slice(0, max));
}

/* â”€â”€ QR spec tables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const QR_CAP = {
  L:[17,32,53,78,106,134,154,192,230,271,321,367,425,458,520,586,644,718,792,858,929,1003,1091,1171,1273,1367,1465,1528,1628,1732,1840,1952,2068,2188,2303,2431,2563,2699,2809,2953],
  M:[14,26,42,62,84,106,122,152,180,213,251,287,331,362,412,450,504,560,624,666,711,779,857,911,997,1059,1125,1190,1264,1370,1452,1538,1628,1722,1809,1911,1989,2099,2213,2331],
  Q:[11,20,32,46,60,74,86,108,130,151,177,203,241,258,292,322,364,394,442,482,509,565,611,661,715,751,805,868,908,982,1030,1112,1168,1228,1283,1351,1423,1499,1579,1663],
  H:[7,14,24,34,44,58,64,84,98,119,137,155,177,194,220,250,280,310,338,382,403,439,461,511,535,593,625,658,698,742,790,842,898,958,983,1051,1093,1139,1219,1273]
};
function getQRVersion(byteLen, ec) {
  const caps = QR_CAP[ec] || QR_CAP.H;
  for (let i = 0; i < caps.length; i++) if (caps[i] >= byteLen) return i + 1;
  return 40;
}
function moduleCount(v) { return 4 * v + 17; }
// 4 module widths quiet zone, proportional to canvas size and QR version
function quietZonePx(v, canvasSize) {
  return Math.ceil(4 * (canvasSize / moduleCount(v)));
}

/* â”€â”€ Contrast math â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function hexLum(hex) {
  const h = safeHex(hex,"#000000");
  const r=parseInt(h.slice(1,3),16)/255, g=parseInt(h.slice(3,5),16)/255, b=parseInt(h.slice(5,7),16)/255;
  const lin = x => x <= 0.03928 ? x/12.92 : Math.pow((x+0.055)/1.055, 2.4);
  return 0.2126*lin(r) + 0.7152*lin(g) + 0.0722*lin(b);
}
function cr(fg, bg) {
  const l1=hexLum(fg), l2=hexLum(bg);
  return (Math.max(l1,l2)+0.05) / (Math.min(l1,l2)+0.05);
}

/* â”€â”€ Finder pattern pixel contrast check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
// Operates on the verify canvas (square, high-contrast) â€” always accurate
function sampleFinderContrast(canvas) {
  try {
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const w = canvas.width;
    const sz = Math.floor(w * 0.08);
    const dark = [], light = [];
    for (let y = sz; y < sz*3; y += 2)
      for (let x = sz; x < sz*3; x += 2) {
        const d = ctx.getImageData(x, y, 1, 1).data;
        const lum = 0.2126*(d[0]/255) + 0.7152*(d[1]/255) + 0.0722*(d[2]/255);
        (lum < 0.5 ? dark : light).push(lum);
      }
    if (!dark.length || !light.length) return { ok: false, sampled: false };
    const avgDark  = dark.reduce((a,b)=>a+b,0)/dark.length;
    const avgLight = light.reduce((a,b)=>a+b,0)/light.length;
    const ratio = (avgLight+0.05)/(avgDark+0.05);
    return { ok: ratio >= 2.5, ratio, sampled: true };
  } catch { return { ok: false, sampled: false }; }
}

/* â”€â”€ Scan status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function scanStatus(fg, bg, ecLevel, logoSize, byteLen, hasMargin, qrVersion, finderOk) {
  const ratio = cr(fg, bg);
  const reasons = []; let bad = 0, caution = 0;
  if (ratio < 2.5)  { bad++;    reasons.push({sev:"bad",    msg:`Contrast ${ratio.toFixed(1)}:1 â€” too low for phone cameras`}); }
  else if (ratio<4) { caution++; reasons.push({sev:"caution",msg:`Contrast ${ratio.toFixed(1)}:1 â€” may fail in poor lighting`}); }
  if (finderOk === false) { bad++; reasons.push({sev:"bad", msg:"Finder pattern pixel-check failed â€” scanner cannot locate QR"}); }
  if (logoSize>0 && ecLevel==="L") { bad++; reasons.push({sev:"bad", msg:"Logo with L correction â€” unreadable, use H"}); }
  else if (logoSize>0 && ecLevel==="M") { caution++; reasons.push({sev:"caution", msg:"Logo with M correction â€” risky, use Q or H"}); }
  if (logoSize > 30) { caution++; reasons.push({sev:"caution", msg:"Logo >30% coverage â€” data modules may be obscured"}); }
  if (qrVersion > 25) { bad++; reasons.push({sev:"bad", msg:`v${qrVersion} QR â€” too dense for most phone cameras`}); }
  else if (qrVersion>15) { caution++; reasons.push({sev:"caution", msg:`v${qrVersion} QR â€” dense, test on multiple phones`}); }
  if (byteLen > 300) { caution++; reasons.push({sev:"caution", msg:"Long payload â€” test carefully on real phones"}); }
  if (!hasMargin) { bad++; reasons.push({sev:"bad", msg:"No quiet zone â€” cameras need white border to locate QR"}); }
  const level = bad > 0 ? "bad" : caution > 0 ? "caution" : "good";
  return { level, label:{good:"Camera Ready",caution:"Some Concerns",bad:"Will Likely Fail"}[level], reasons };
}

/* â”€â”€ Print DPI calculator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function calcPrint(qrVersion, printSizeIn, dpi) {
  if (!qrVersion || !printSizeIn || !dpi) return null;
  const mc = moduleCount(qrVersion);
  const mmPerModule = (printSizeIn * 25.4) / mc;
  if (mmPerModule < 0.25) return {level:"bad",  msg:`${mmPerModule.toFixed(2)}mm/module â€” below ISO minimum (0.25mm)`};
  if (mmPerModule < 0.33) return {level:"warn", msg:`${mmPerModule.toFixed(2)}mm/module â€” marginal for phone cameras`};
  return {level:"ok", msg:`${mmPerModule.toFixed(2)}mm/module â€” readable at this print size`};
}

/* â”€â”€ vCard / field validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function validateFields(type, fields) {
  const errs = {};
  if (type==="email"||type==="vcard") {
    const e=(fields.email||"").trim();
    if (e && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)) errs.email="Invalid email format";
  }
  if (type==="url") {
    const u=(fields.url||"").trim();
    if (u && u.length>MAX_URL) errs.url=`URL too long (max ${MAX_URL} chars)`;
    else if (u && !/^(https?:\/\/)?[\w\-.]+\.[\w\-.]+/.test(u)) errs.url="Invalid URL format";
  }
  if (type==="wifi" && !(fields.ssid||"").trim()) errs.ssid="SSID required";
  if (type==="vcard" && !(fields.firstName||"").trim() && !(fields.lastName||"").trim())
    errs.firstName="At least one name required";
  return errs;
}

/* â”€â”€ RFC 6350 vCard escaping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function vcEsc(v)  { return capField(v,MAX_FIELD).replace(/\\/g,"\\\\").replace(/;/g,"\\;").replace(/,/g,"\\,"); }
function vcTel(v)  { return (v||"").replace(/[^\d+\-().\s]/g,"").trim().slice(0,30); }
function wfEsc(v)  { return (v||"").replace(/\\/g,"\\\\").replace(/:/g,"\\:").replace(/;/g,"\\;").replace(/,/g,"\\,"); }

/* â”€â”€ Data builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function buildData(type, f) {
  switch(type) {
    case "url": {
      let u = capField(f.url||"", MAX_URL).trim();
      if (u && !/^https?:\/\//i.test(u)) u = "https://"+u;
      return u;
    }
    case "text":  return capField(f.text||"", MAX_TEXT);
    case "email": return `mailto:${(f.email||"").trim()}?subject=${encodeURIComponent(capField(f.subject||"",200))}&body=${encodeURIComponent(capField(f.body||"",1000))}`;
    case "sms":   return `sms:${vcTel(f.phone)}${f.message?`?body=${encodeURIComponent(capField(f.message||"",160))}`:""}`; // fixed: capField(val, max) correct arg order
    case "phone": return `tel:${vcTel(f.phone)}`;
    case "wifi":  return `WIFI:T:${f.security||"WPA"};S:${wfEsc(capField(f.ssid||"",64))};P:${wfEsc(capField(f.password||"",64))};;`;
    case "vcard": {
      const fn = [f.firstName,f.lastName].filter(Boolean).map(vcEsc).join(" ");
      return [
        "BEGIN:VCARD","VERSION:3.0",
        `FN:${fn}`,
        `N:${vcEsc(f.lastName||"")};${vcEsc(f.firstName||"")};;;`,
        `ORG:${vcEsc(f.org||"")}`,
        `TEL:${vcTel(f.phone)}`,
        `EMAIL:${(f.email||"").trim().slice(0,254)}`,
        `URL:${(f.website||"").trim().slice(0,MAX_URL)}`,
        `ADR:;;${vcEsc(f.address||"")};;;;`,
        "END:VCARD"
      ].join("\n");
    }
    default: return "";
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   NATIVE CANVAS RENDERER v7
   Uses qrcode-generator's isDark(row, col) API â€” no matrix hacks.
   Pattern: draw all data modules â†’ overdraw 3 finder eyes on top.
   Dual canvas: display (styled, HiDPI) + verify (square, B&W, 300px).
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Draw a single data module */
function drawModule(ctx, x, y, sz, dotStyle, color) {
  ctx.fillStyle = color;
  if (dotStyle === "dots") {
    ctx.beginPath();
    ctx.arc(x+sz/2, y+sz/2, sz/2*0.82, 0, Math.PI*2);
    ctx.fill();
  } else if (dotStyle === "rounded") {
    const r = sz * 0.28;
    roundFill(ctx, x, y, sz, sz, r);
  } else {
    ctx.fillRect(x, y, sz, sz); // square â€” fastest
  }
}

/* Rounded rectangle fill helper */
function roundFill(ctx, x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y); ctx.arcTo(x+w, y,   x+w, y+r,   r);
  ctx.lineTo(x+w, y+h-r); ctx.arcTo(x+w, y+h, x+w-r, y+h, r);
  ctx.lineTo(x+r, y+h);   ctx.arcTo(x,   y+h, x,   y+h-r, r);
  ctx.lineTo(x, y+r);     ctx.arcTo(x,   y,   x+r, y,     r);
  ctx.closePath(); ctx.fill();
}

/* Draw one finder eye (7Ã—7 modules at offset ox,oy in pixel space) */
function drawFinder(ctx, ox, oy, modSz, eyeStyle, fgColor, bgColor) {
  const total = modSz * 7;
  ctx.fillStyle = fgColor;
  // Outer ring
  if (eyeStyle === "rounded") {
    roundFill(ctx, ox, oy, total, total, modSz * 1.0);
  } else if (eyeStyle === "dot") {
    // Outer as rounded square
    roundFill(ctx, ox, oy, total, total, modSz * 0.6);
  } else {
    ctx.fillRect(ox, oy, total, total); // square
  }
  // Inner clear (5Ã—5)
  ctx.fillStyle = bgColor;
  if (eyeStyle === "rounded") {
    roundFill(ctx, ox+modSz, oy+modSz, modSz*5, modSz*5, modSz*0.6);
  } else if (eyeStyle === "dot") {
    roundFill(ctx, ox+modSz, oy+modSz, modSz*5, modSz*5, modSz*0.4);
  } else {
    ctx.fillRect(ox+modSz, oy+modSz, modSz*5, modSz*5);
  }
  // Center dot (3Ã—3)
  ctx.fillStyle = fgColor;
  if (eyeStyle === "dot") {
    ctx.beginPath();
    ctx.arc(ox+modSz*3.5, oy+modSz*3.5, modSz*1.4, 0, Math.PI*2);
    ctx.fill();
  } else if (eyeStyle === "rounded") {
    roundFill(ctx, ox+modSz*2, oy+modSz*2, modSz*3, modSz*3, modSz*0.4);
  } else {
    ctx.fillRect(ox+modSz*2, oy+modSz*2, modSz*3, modSz*3);
  }
}

/*
  renderToCanvas(qr, canvasSize, opts) â€” renders onto a new canvas.
  qr         â€” qrcode-generator instance (after make())
  canvasSize â€” target pixel size (square)
  opts: { dotStyle, eyeStyle, fgColor, bgColor, hasMargin, logoSrc, logoSize }
  Returns: Promise<HTMLCanvasElement>
*/
async function renderToCanvas(qr, canvasSize, opts) {
  const mc = qr.getModuleCount();
  const qzModules = opts.hasMargin ? 4 : 0;
  const modSz = canvasSize / (mc + qzModules * 2);
  const offset = qzModules * modSz;

  const canvas = document.createElement("canvas");
  canvas.width = canvasSize; canvas.height = canvasSize;

  // Display canvas: no willReadFrequently (better GPU compositing for crisp render)
  // Verify canvas: willReadFrequently set by caller via separate call
  const ctx = canvas.getContext("2d");

  // Background
  ctx.fillStyle = opts.bgColor;
  ctx.fillRect(0, 0, canvasSize, canvasSize);

  // Finder eye corner positions in module coords
  const size = mc;
  const finderZones = [
    {r:0,c:0}, {r:0,c:size-7}, {r:size-7,c:0}
  ];
  // Build a fast Set of "is this module inside a finder zone"
  const inFinder = new Set();
  for (const {r,c} of finderZones)
    for (let dr=0;dr<7;dr++) for (let dc=0;dc<7;dc++) inFinder.add((r+dr)*size+(c+dc));

  // Draw data modules (skip finder zones â€” they are overdrawn below)
  for (let row = 0; row < size; row++) {
    for (let col = 0; col < size; col++) {
      if (!qr.isDark(row, col)) continue;
      if (inFinder.has(row*size+col)) continue;
      drawModule(ctx, offset+col*modSz, offset+row*modSz, modSz, opts.dotStyle, opts.fgColor);
    }
  }

  // Overdraw finder eyes â€” always correct style regardless of isDark values
  for (const {r,c} of finderZones) {
    drawFinder(ctx, offset+c*modSz, offset+r*modSz, modSz, opts.eyeStyle, opts.fgColor, opts.bgColor);
  }

  // Logo overlay (validated data URI only)
  if (opts.logoSrc && isSafeImageDataURI(opts.logoSrc)) {
    await new Promise(resolve => {
      const img = new Image();
      img.onload = () => {
        const lsz = Math.floor(canvasSize * (opts.logoSize / 100));
        const lx = (canvasSize - lsz) / 2;
        const ly = (canvasSize - lsz) / 2;
        const pad = lsz * 0.1;
        ctx.fillStyle = opts.bgColor;
        roundFill(ctx, lx-pad, ly-pad, lsz+pad*2, lsz+pad*2, pad*0.8);
        ctx.drawImage(img, lx, ly, lsz, lsz);
        resolve();
      };
      img.onerror = resolve;
      img.src = opts.logoSrc;
    });
  }

  return canvas;
}

/*
  renderVerifyCanvas(qr, size) â€” always square, black on white.
  Used ONLY for ZXing verify and finder contrast check.
  Completely separate from the display canvas.
*/
function renderVerifyCanvas(qr, size) {
  const mc = qr.getModuleCount();
  const qzModules = 4; // always include quiet zone for verify
  const modSz = size / (mc + qzModules * 2);
  const offset = qzModules * modSz;

  const canvas = document.createElement("canvas");
  canvas.width = size; canvas.height = size;
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0, 0, size, size);
  ctx.fillStyle = "#000000";
  for (let row = 0; row < mc; row++)
    for (let col = 0; col < mc; col++)
      if (qr.isDark(row, col))
        ctx.fillRect(offset+col*modSz, offset+row*modSz, modSz, modSz);

  return canvas;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   QRController v7 â€” single source of truth for generation
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QRC = (() => {
  let _lastSig = null;

  // EC clamping for logos
  function clampEC(ec, logoSrc, logoSize) {
    if (!logoSrc || !logoSize) return ec;
    if (ec==="L") return "H";
    if (ec==="M" && logoSize>15) return "H";
    if (ec==="M") return "Q";
    return ec;
  }

  function mount() { return document.getElementById("qr-mount"); }

  function sig(o) {
    return [o.data,o.dotStyle,o.eyeStyle,o.fgColor,o.bgColor,o.ecLevel,
            o.logoSrc?"y":"n",o.logoSize,o.hasMargin].join("|");
  }

  // qrcode-generator EC level mapping
  const EC_MAP = { L:"L", M:"M", Q:"Q", H:"H" };

  async function generate(opts) {
    const el = mount(); if (!el) return;

    const safeFg  = safeHex(opts.fgColor, "#000000");
    const safeBg  = safeHex(opts.bgColor, "#ffffff");
    const effEC   = clampEC(opts.ecLevel, opts.logoSrc, opts.logoSize);

    // Validate dot/eye styles against known safe values
    const dotStyle = ["square","dots","rounded"].includes(opts.dotStyle) ? opts.dotStyle : "square";
    const eyeStyle = ["square","dot","rounded"].includes(opts.eyeStyle) ? opts.eyeStyle : "square";

    const sanitized = { ...opts, fgColor:safeFg, bgColor:safeBg, ecLevel:effEC, dotStyle, eyeStyle };
    const s = sig(sanitized);
    if (s === _lastSig) return;
    _lastSig = s;

    update({ verifyStatus:"checking", finderOk:null });

    try {
      const qrcGen = await ensureQRG();

      // qrcode-generator: qrcode(typeNumber, errorCorrectionLevel)
      // typeNumber 0 = auto-detect version
      const qr = qrcGen(0, EC_MAP[effEC]);
      qr.addData(sanitized.data);
      qr.make();

      const version = (qr.getModuleCount() - 17) / 4;
      update({ qrVersion: version });

      // HiDPI display canvas
      const dpr = Math.min(window.devicePixelRatio || 1, 3);
      const displaySize = Math.round(Math.max(380, 380 * dpr));

      const displayCanvas = await renderToCanvas(qr, displaySize, sanitized);
      // CSS scaling â€” always fills the mount container
      displayCanvas.style.width  = "100%";
      displayCanvas.style.height = "auto";

      // Replace mount contents with new canvas
      el.innerHTML = "";
      el.appendChild(displayCanvas);

      update({ hasQR: true });

      // Verify canvas: square black-on-white 400px â€” separate from display
      const verifyCanvas = renderVerifyCanvas(qr, 400);
      const fc = sampleFinderContrast(verifyCanvas);
      update({ finderOk: fc.sampled ? fc.ok : null });

      // ZXing verify on the B&W verify canvas â€” not the display canvas
      autoVerify(sanitized.data, verifyCanvas);

    } catch(e) {
      toast("QR generation failed: " + e.message, "er");
      update({ verifyStatus:null, hasQR:false, qrVersion:1, finderOk:null });
    }
  }

  function clear() {
    const el = mount(); if (!el) return;
    _lastSig = null;
    el.innerHTML = "";
    // Restore empty hint
    const hint = document.createElement("div"); hint.className="empty-hint";
    const big = document.createElement("div"); big.className="big"; big.textContent="â–£";
    const txt = document.createElement("div"); txt.className="txt"; txt.textContent="Enter data to generate";
    hint.appendChild(big); hint.appendChild(txt); el.appendChild(hint);
    update({ verifyStatus:null, hasQR:false, qrVersion:1, finderOk:null });
  }

  function getClampEC(ec, ls, lsz) { return clampEC(ec, ls, lsz); }
  return { generate, clear, clampEC: getClampEC };
})();

/* â”€â”€ autoVerify: MultiFormatReader + BinaryBitmap (zero PNG round-trip) â”€â”€ */
let _zxReader = null;
async function autoVerify(expectedData, verifyCanvas) {
  try {
    update({ verifyStatus:"loading" });
    const ZXing = await ensureZXing();
    update({ verifyStatus:"checking" });

    if (!_zxReader) {
      const hints = new Map();
      hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [ZXing.BarcodeFormat.QR_CODE]);
      hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
      _zxReader = new ZXing.MultiFormatReader();
      _zxReader.setHints(hints);
    }

    // Zero-copy: BinaryBitmap directly from canvas luminance
    const lum = new ZXing.HTMLCanvasElementLuminanceSource(verifyCanvas);
    const bmp = new ZXing.BinaryBitmap(new ZXing.HybridBinarizer(lum));

    let decoded = null;
    try { decoded = _zxReader.decode(bmp)?.getText() ?? null; }
    catch { decoded = null; }

    const passed = decoded === expectedData;
    update({ verifyStatus: passed ? "pass" : "fail" });
    if (!passed && decoded) console.warn("[QR v7] Mismatch\nExpected:", expectedData, "\nDecoded:", decoded);
  } catch {
    update({ verifyStatus: null });
  }
}

/* â”€â”€ Download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function dlQR() {
  const c = document.getElementById("qr-mount")?.querySelector("canvas");
  if (!c) { toast("Generate a QR first","wn"); return; }
  const a = document.createElement("a");
  a.href = c.toDataURL("image/png"); a.download = "qrcode.png"; a.click();
}

/* â”€â”€ Copy image â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function copyImg() {
  const c = document.getElementById("qr-mount")?.querySelector("canvas");
  if (!c) { toast("Generate a QR first","wn"); return; }
  c.toBlob(async blob => {
    try {
      await navigator.clipboard.write([new ClipboardItem({"image/png":blob})]);
      update({imgCopied:true}); setTimeout(()=>update({imgCopied:false}),2000);
      toast("Image copied","ok");
    } catch { toast("Clipboard unavailable â€” use Download","wn"); }
  });
}

/* â”€â”€ Copy data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function copyData(raw) {
  try {
    await navigator.clipboard.writeText(raw);
    update({dataCopied:true}); setTimeout(()=>update({dataCopied:false}),2000);
    toast("Copied","ok");
  } catch { toast("Clipboard write failed","er"); }
}

/* â”€â”€ Batch: qrcode-generator (same path as main) + JSZip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function runBatch(csvText) {
  if (new TextEncoder().encode(csvText).length > BATCH_MAX_BYTES) { toast("CSV too large (max 5MB)","wn"); return; }
  const lines = csvText.trim().split(/\r?\n/).filter(l=>l.trim());
  if (!lines.length) { toast("CSV is empty","wn"); return; }
  if (lines.length > BATCH_MAX_ROWS) { toast(`Too many rows (max ${BATCH_MAX_ROWS})`,"wn"); return; }

  update({ batchProgress:{done:0,total:lines.length}, batchBlob:null });

  try {
    const [qrcGen, JSZip] = await Promise.all([ensureQRG(), ensureJSZip()]);
    const zip = new JSZip();

    for (let i = 0; i < lines.length; i++) {
      const row = lines[i].split(",");
      const label = (row[0]||"").trim().replace(/[^\w\-]/g,"_").slice(0,64) || `qr_${i+1}`;
      let data = capField((row[1]||row[0]||"").trim(), MAX_URL);
      if (!data) { update({batchProgress:{done:i+1,total:lines.length},batchBlob:null}); continue; }
      if (!/^https?:\/\//i.test(data) && /\./.test(data)) data = "https://"+data;

      const qr = qrcGen(0, S.ecLevel);
      qr.addData(data); qr.make();

      // Batch uses square style for reliability
      const canvas = await renderToCanvas(qr, 600, {
        dotStyle:"square", eyeStyle:"square",
        fgColor: safeHex(S.fgColor,"#000000"),
        bgColor: safeHex(S.bgColor,"#ffffff"),
        hasMargin: S.hasMargin,
        logoSrc: null, logoSize: 0
      });

      const blob = await new Promise(res => canvas.toBlob(res, "image/png"));
      zip.file(label+".png", blob);
      update({ batchProgress:{done:i+1,total:lines.length}, batchBlob:null });
      await new Promise(r => setTimeout(r,0)); // yield to UI
    }

    const zipBlob = await zip.generateAsync({type:"blob",compression:"DEFLATE"});
    update({ batchProgress:null, batchBlob:zipBlob });
    toast(`${lines.length} QR codes ready`,"ok");
  } catch(e) {
    toast("Batch failed: "+e.message,"er");
    update({ batchProgress:null });
  }
}

function downloadBatch() {
  if (!S.batchBlob) return;
  const a = document.createElement("a");
  a.href = URL.createObjectURL(S.batchBlob);
  a.download = "qrcodes.zip"; a.click();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QR_TYPES=[
  {id:"url",  label:"URL",   icon:"ğŸ”—"}, {id:"text", label:"Text",  icon:"ğŸ“"},
  {id:"email",label:"Email", icon:"âœ‰ï¸"}, {id:"sms",  label:"SMS",   icon:"ğŸ’¬"},
  {id:"phone",label:"Phone", icon:"ğŸ“"}, {id:"wifi", label:"WiFi",  icon:"ğŸ“¶"},
  {id:"vcard",label:"vCard", icon:"ğŸ‘¤"},
];
// Dot styles: only options natively supported by the renderer
const DOT_STYLES  = ["square","dots","rounded"];
const DOT_LABELS  = {square:"Square", dots:"Dots", rounded:"Rounded"};
// Eye styles: square, rounded, dot â€” consistent naming throughout
const EYE_STYLES  = ["square","rounded","dot"];
const EYE_LABELS  = {square:"Square", rounded:"Round", dot:"Dot"};
const EC_LEVELS   = ["L","M","Q","H"];
const TEMPLATES   = [
  {name:"Acid",     bg:"#0c0f0a", fg:"#b8f400"}, {name:"Obsidian", bg:"#0d0d0d", fg:"#ffffff"},
  {name:"Blueprint",bg:"#0a1628", fg:"#4da6ff"}, {name:"Ember",    bg:"#1a0800", fg:"#ff6b35"},
  {name:"Sakura",   bg:"#1a0d12", fg:"#ff8fab"}, {name:"Matrix",   bg:"#001a00", fg:"#00ff41"},
  {name:"Chalk",    bg:"#fafaf8", fg:"#1a1a1a"}, {name:"Gold",     bg:"#0f0c00", fg:"#ffd700"},
];

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   localStorage â€” type-safe, key-scoped
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const KNOWN_TYPES = new Set(QR_TYPES.map(t=>t.id));
function lsGet(k, fb) {
  try {
    const v = localStorage.getItem(k); if (!v) return fb;
    const p = JSON.parse(v);
    if (typeof p!=="object"||p===null||Array.isArray(p)) return fb;
    return p;
  } catch { return fb; }
}
function lsSet(k, v) {
  try { localStorage.setItem(k, JSON.stringify(v)); }
  catch(e) { if(e.name==="QuotaExceededError"||e.code===22) toast("Storage full","wn"); }
}
function lsSetFields(type, fields) {
  if (!KNOWN_TYPES.has(type)) return;
  lsSet("qrs_fields_"+type, fields);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const S = {
  qrType:    "url",
  fields:    lsGet("qrs_fields_url", {}),
  fieldErrs: {},
  dotStyle:  "square",
  eyeStyle:  "square",
  fgColor:   "#b8f400",
  bgColor:   "#0c0f0a",
  ecLevel:   "H",
  logoSrc:   null,
  logoSize:  20,
  hasMargin: true,
  customTab: "style",
  verifyStatus: null,
  hasQR:     false,
  imgCopied: false,
  dataCopied:false,
  lowlight:  false,
  qrVersion: 1,
  finderOk:  null,
  printSize: 2,
  printDPI:  300,
  batchProgress: null,
  batchBlob: null,
};

let _raf = false;
function update(patch, afterRender) {
  Object.assign(S, typeof patch==="function" ? patch(S) : patch);
  if (!_raf) { _raf=true; requestAnimationFrame(()=>{ render(); _raf=false; if(afterRender) afterRender(); }); }
}

/* â”€â”€ h() â€” virtual DOM helper (no innerHTML anywhere) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function h(tag, attrs={}, ...kids) {
  const el = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) {
    if (v===null||v===undefined||v===false) continue;
    if (k==="class")  el.className = v;
    else if (k==="style" && typeof v==="object") Object.assign(el.style, v);
    else if (k==="value")   el.value = v;
    else if (k==="checked") el.checked = !!v;
    else if (k==="selected") el.selected = !!v;
    else if (k==="disabled") el.disabled = !!v;
    else if (k.startsWith("on") && typeof v==="function") el.addEventListener(k.slice(2).toLowerCase(), v);
    else el.setAttribute(k, v);
  }
  for (const c of kids.flat(Infinity)) {
    if (c==null||c===false||c===true||c===undefined) continue;
    if (typeof c==="string"||typeof c==="number") el.appendChild(document.createTextNode(String(c)));
    else if (c instanceof Node) el.appendChild(c);
  }
  return el;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PERSISTENT DOM â€” never replaced by render()
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QR_MOUNT = (() => {
  const el = document.createElement("div"); el.id="qr-mount"; el.className="qr-mount empty";
  const hint=document.createElement("div"); hint.className="empty-hint";
  const big=document.createElement("div");  big.className="big";  big.textContent="â–£";
  const txt=document.createElement("div");  txt.className="txt";  txt.textContent="Enter data to generate";
  hint.appendChild(big); hint.appendChild(txt); el.appendChild(hint);
  return el;
})();

const FORM_EL = document.createElement("div");
FORM_EL.id = "form-container";

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FORM PATCHING â€” cursor-safe, in-place updates
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function patchInput(container, key, label, placeholder, type="text") {
  let wrap = container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap=document.createElement("div"); wrap.className="fld"; wrap.setAttribute("data-key",key);
    const lbl=document.createElement("div"); lbl.className="lbl"; lbl.textContent=label;
    const inp=document.createElement("input"); inp.type=type; inp.placeholder=placeholder;
    const err=document.createElement("div"); err.className="fld-err";
    inp.addEventListener("input", e => {
      const nf={...S.fields,[key]:e.target.value};
      const errs=validateFields(S.qrType,nf);
      update({fields:nf,fieldErrs:errs}); lsSetFields(S.qrType,nf); scheduleQR(nf);
    });
    wrap.appendChild(lbl); wrap.appendChild(inp); wrap.appendChild(err);
    container.appendChild(wrap);
  }
  const inp=wrap.querySelector("input"); const err=wrap.querySelector(".fld-err");
  if (document.activeElement!==inp && inp.value!==(S.fields[key]||"")) inp.value=S.fields[key]||"";
  inp.type=type; inp.placeholder=placeholder;
  wrap.querySelector(".lbl").textContent=label;
  const msg=S.fieldErrs[key];
  if (msg) { inp.classList.add("err"); err.textContent=msg; err.classList.add("show"); }
  else      { inp.classList.remove("err"); err.textContent=""; err.classList.remove("show"); }
}

function patchTextarea(container, key, label, placeholder) {
  let wrap=container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap=document.createElement("div"); wrap.className="fld"; wrap.setAttribute("data-key",key);
    const lbl=document.createElement("div"); lbl.className="lbl"; lbl.textContent=label;
    const ta=document.createElement("textarea"); ta.placeholder=placeholder;
    ta.addEventListener("input", e => {
      const nf={...S.fields,[key]:e.target.value};
      update({fields:nf}); lsSetFields(S.qrType,nf); scheduleQR(nf);
    });
    wrap.appendChild(lbl); wrap.appendChild(ta); container.appendChild(wrap);
  }
  const ta=wrap.querySelector("textarea");
  if (document.activeElement!==ta && ta.value!==(S.fields[key]||"")) ta.value=S.fields[key]||"";
  ta.placeholder=placeholder;
}

function patchSelect(container, key, label, options) {
  let wrap=container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap=document.createElement("div"); wrap.className="fld"; wrap.setAttribute("data-key",key);
    const lbl=document.createElement("div"); lbl.className="lbl"; lbl.textContent=label;
    const sel=document.createElement("select");
    options.forEach(o=>{const op=document.createElement("option");op.value=o;op.textContent=o;sel.appendChild(op);});
    sel.addEventListener("change",e=>{const nf={...S.fields,[key]:e.target.value};update({fields:nf});lsSetFields(S.qrType,nf);scheduleQR(nf);});
    wrap.appendChild(lbl); wrap.appendChild(sel); container.appendChild(wrap);
  }
  wrap.querySelector("select").value=S.fields[key]||options[0];
}

function buildForm(container) {
  const needed=getNeededKeys(S.qrType);
  [...container.querySelectorAll("[data-key]")].forEach(el=>{
    if(!needed.includes(el.dataset.key)) el.remove();
  });
  if (S.qrType!=="vcard") { const tc=container.querySelector(".two"); if(tc)tc.remove(); }
  switch(S.qrType) {
    case "url":   patchInput(container,"url","Website URL","https://example.com","url"); break;
    case "text":  patchTextarea(container,"text","Text Content","Any text, code, messageâ€¦"); break;
    case "email": patchInput(container,"email","Email","you@example.com","email"); patchInput(container,"subject","Subject","Subject line"); patchTextarea(container,"body","Body","Messageâ€¦"); break;
    case "sms":   patchInput(container,"phone","Phone Number","+1 555 000 0000","tel"); patchTextarea(container,"message","Message","SMS bodyâ€¦"); break;
    case "phone": patchInput(container,"phone","Phone Number","+1 555 000 0000","tel"); break;
    case "wifi":  patchInput(container,"ssid","Network SSID","MyWiFiNetwork"); patchInput(container,"password","Password","WiFi password","password"); patchSelect(container,"security","Security",["WPA","WPA2","WEP","None"]); break;
    case "vcard": {
      let tc=container.querySelector(".two");
      if(!tc){tc=document.createElement("div");tc.className="two";container.insertBefore(tc,container.firstChild);}
      [...tc.querySelectorAll("[data-key]")].forEach(el=>{if(!["firstName","lastName"].includes(el.dataset.key))el.remove();});
      patchInput(tc,"firstName","First Name","John");
      patchInput(tc,"lastName","Last Name","Doe");
      patchInput(container,"org","Organization","Company Name");
      patchInput(container,"phone","Phone","+1 555 000 0000","tel");
      patchInput(container,"email","Email","john@example.com","email");
      patchInput(container,"website","Website","https://example.com","url");
      patchInput(container,"address","Address","123 Main St, City");
      break;
    }
  }
}

function getNeededKeys(type) {
  return {
    url:["url"],text:["text"],email:["email","subject","body"],sms:["phone","message"],
    phone:["phone"],wifi:["ssid","password","security"],
    vcard:["firstName","lastName","org","phone","email","website","address"]
  }[type]||[];
}

/* â”€â”€ QR scheduling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _qrTimer = null;
function scheduleQR(fields) {
  if (_qrTimer) clearTimeout(_qrTimer);
  _qrTimer = setTimeout(()=>triggerQR(fields), 180);
}
function triggerQR(fields) {
  _qrTimer = null;
  const f = fields !== undefined ? fields : S.fields;
  const errs = validateFields(S.qrType, f);
  if (Object.keys(errs).length) { QRC.clear(); return; }
  const raw = buildData(S.qrType, f);
  if (!raw.trim()) { QRC.clear(); return; }
  QRC.generate({
    data:    raw,
    dotStyle:S.dotStyle,
    eyeStyle:S.eyeStyle,
    fgColor: S.fgColor,
    bgColor: S.bgColor,
    ecLevel: S.ecLevel,
    logoSrc: S.logoSrc,
    logoSize:S.logoSize,
    hasMargin:S.hasMargin,
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RENDER â€” UI components
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const tog = (on, onClick) => h("button",{class:"tog"+(on?" on":""),onClick},h("div",{class:"tog-k"}));

function rHeader() {
  return h("header",{},h("div",{class:"hdr-inner"},
    h("div",{class:"logo"},
      h("div",{class:"logo-box"},"â–£"),
      h("div",{class:"logo-name"},"QR",h("span",{},"_"),"studio")
    ),
    h("div",{class:"hdr-badges"},
      h("div",{class:"hdr-badge v7"},"v7"),
      h("div",{class:"hdr-badge"},"ENCODE")
    )
  ));
}

function rTypeSelector() {
  return h("div",{},
    h("div",{class:"sec-label",style:"margin-bottom:12px"},"â—ˆ Content Type"),
    h("div",{class:"type-grid"},
      QR_TYPES.map(t=>h("button",{
        class:"type-btn"+(S.qrType===t.id?" on":""),
        onClick:()=>{
          if(S.qrType===t.id) return;
          const saved=lsGet("qrs_fields_"+t.id,{});
          const errs=validateFields(t.id,saved);
          update({qrType:t.id,fields:saved,fieldErrs:errs},()=>{buildForm(FORM_EL);triggerQR(saved);});
        }
      },h("span",{class:"ico"},t.icon),t.label))
    )
  );
}

function rStyleTab() {
  const isFast = S.dotStyle==="square" && S.eyeStyle==="square" && !S.logoSrc;
  return h("div",{},
    h("div",{class:"lbl"},"Module Shape"),
    h("div",{class:"opt-grid cols3",style:"margin-bottom:14px"},
      DOT_STYLES.map(d=>h("button",{class:"opt-btn"+(S.dotStyle===d?" on":""),onClick:()=>{update({dotStyle:d});triggerQR();}},DOT_LABELS[d]))
    ),
    h("div",{class:"lbl"},"Eye / Finder Style"),
    h("div",{class:"opt-grid cols3b",style:"margin-bottom:14px"},
      EYE_STYLES.map(e=>h("button",{class:"opt-btn"+(S.eyeStyle===e?" on":""),onClick:()=>{update({eyeStyle:e});triggerQR();}},EYE_LABELS[e]))
    ),
    h("div",{class:"notice"},
      isFast
        ? h("span",{},[h("strong",{},"âš¡ Fast path: "),"Square modules, no external styling library. Instant generation."])
        : h("span",{},[h("strong",{},"ğŸ¨ Styled: "),"Custom shapes rendered natively on canvas."])
    )
  );
}

function rColorsTab() {
  const cRow = (label, val, onChange) => h("div",{class:"c-row"},
    h("span",{class:"c-lbl"},label),
    h("div",{class:"c-ctrl"},
      h("div",{class:"swatch",style:{background:safeHex(val,"#000")}},
        h("input",{type:"color",value:safeHex(val,"#000000"),onInput:e=>{onChange(e.target.value);triggerQR();}})
      ),
      h("input",{type:"text",class:"hex",value:val,
        onInput:e=>{if(/^#[0-9a-fA-F]{0,6}$/.test(e.target.value.trim())){onChange(e.target.value.trim());triggerQR();}}
      })
    )
  );
  return h("div",{},
    h("div",{class:"lbl"},"Templates"),
    h("div",{class:"tpl-row"},
      TEMPLATES.map(t=>h("button",{class:"tpl",onClick:()=>{update({bgColor:t.bg,fgColor:t.fg});triggerQR();}},
        h("div",{style:{width:"12px",height:"12px",borderRadius:"3px",background:t.fg,flexShrink:"0"}}),t.name
      ))
    ),
    cRow("Foreground", S.fgColor, v=>update({fgColor:v})),
    cRow("Background", S.bgColor, v=>update({bgColor:v})),
    h("div",{class:"notice",style:"margin-top:12px"},
      h("strong",{},"Contrast tip: "),
      `Current ratio: ${cr(S.fgColor,S.bgColor).toFixed(1)}:1. Aim for 4:1+ for reliable phone camera scans.`
    )
  );
}

function rAdvancedTab(status, rawData) {
  const effEC   = QRC.clampEC(S.ecLevel, S.logoSrc, S.logoSize);
  const dc      = {good:"var(--a)",caution:"var(--warn)",bad:"var(--danger)"};
  const si      = {good:"âœ“",caution:"âš ",bad:"âœ•"};
  const dpiRes  = S.hasQR ? calcPrint(S.qrVersion, S.printSize, S.printDPI) : null;

  return h("div",{},
    // EC level
    h("div",{class:"lbl"},"Error Correction"),
    h("div",{class:"ec-row"},
      EC_LEVELS.map(l=>{
        const isSel = S.ecLevel===l;
        const isClamp = effEC!==S.ecLevel && l===effEC;
        return h("button",{
          class:"ecb"+(isSel?" on":"")+(isClamp&&!isSel?" clamped":""),
          title:isClamp&&!isSel?"Auto-upgraded â€” logo requires higher EC":"",
          onClick:()=>{update({ecLevel:l});triggerQR();}
        },l+(isClamp&&!isSel?"â†‘":""));
      })
    ),
    h("div",{class:"ec-hint"},"L=7%  M=15%  Q=25%  H=30% recovery\nH recommended for logos and styled QR"),

    // Logo
    h("div",{class:"lbl",style:"margin-top:16px"},"Logo / Icon"),
    S.logoSrc
      ? h("div",{class:"logo-prev"},
          h("img",{class:"logo-img",src:S.logoSrc,alt:"logo"}),
          h("div",{style:"flex:1"},
            h("div",{style:"font-size:11px;color:var(--mut);margin-bottom:5px"},`Size: ${S.logoSize}%`),
            h("input",{type:"range",min:10,max:35,value:S.logoSize,style:"width:100%",
              onInput:e=>{update({logoSize:+e.target.value});triggerQR();}
            })
          ),
          h("button",{class:"logo-rm",onClick:()=>{update({logoSrc:null,logoSize:20});triggerQR();}},"Ã—")
        )
      : h("button",{class:"logo-up",onClick:()=>document.getElementById("logo-inp")?.click()},
          h("span",{style:"font-size:20px"},"â¬†"),
          h("span",{style:"font-size:13px;font-weight:600"},"Upload Logo"),
          h("span",{style:"font-size:10px;color:rgba(184,244,0,.35)"},"PNG, JPEG, GIF, WebP Â· max 2MB")
        ),
    h("input",{id:"logo-inp",type:"file",accept:"image/png,image/jpeg,image/gif,image/webp",style:"display:none",
      onChange:e=>{
        const f=e.target.files?.[0]; if(!f) return;
        if(!/^image\/(png|jpeg|gif|webp)$/.test(f.type)){toast("Only PNG/JPEG/GIF/WebP allowed","wn");return;}
        if(f.size>2*1024*1024){toast("Logo too large (max 2MB)","wn");return;}
        const r=new FileReader();
        r.onload=ev=>{
          if(!isSafeImageDataURI(ev.target.result)){toast("Invalid image data","er");return;}
          update({logoSrc:ev.target.result,ecLevel:"H"}); triggerQR();
        };
        r.readAsDataURL(f);
      }
    }),

    // Quiet zone
    h("div",{style:"margin-top:14px;display:flex;align-items:center;gap:9px;margin-bottom:8px"},
      tog(S.hasMargin,()=>{update({hasMargin:!S.hasMargin});triggerQR();}),
      h("span",{class:"tog-lbl",onClick:()=>{update({hasMargin:!S.hasMargin});triggerQR();}},"Quiet zone margin")
    ),
    h("div",{class:"notice"},
      h("strong",{},"Quiet zone: "),
      S.hasQR
        ? `${quietZonePx(S.qrVersion, Math.max(380,380*Math.min(window.devicePixelRatio||1,3)))}px (4 module widths, v${S.qrVersion})`
        : "4 module widths, proportional to QR version â€” keep enabled"
    ),

    // Print DPI
    h("div",{class:"dpi-wrap"},
      h("div",{class:"dpi-title"},"â—ˆ Print Readability"),
      h("div",{class:"dpi-row"},
        h("div",{},h("div",{class:"lbl"},"Print size (in)"),
          h("input",{type:"number",value:S.printSize,min:0.5,max:24,step:0.5,
            onInput:e=>{update({printSize:parseFloat(e.target.value)||2});}})
        ),
        h("div",{},h("div",{class:"lbl"},"DPI"),
          h("input",{type:"number",value:S.printDPI,min:72,max:1200,step:1,
            onInput:e=>{update({printDPI:parseInt(e.target.value)||300});}})
        )
      ),
      dpiRes
        ? h("div",{class:"dpi-result "+dpiRes.level},dpiRes.msg)
        : h("div",{class:"dpi-result empty"},"Generate a QR to see print analysis")
    ),

    // Scan readiness
    h("div",{class:"scan-box "+status.level},
      h("div",{class:"scan-hdr"},
        h("div",{class:"scan-dot",style:{background:dc[status.level]}}),
        h("div",{class:"scan-title",style:{color:dc[status.level]}},status.label)
      ),
      status.reasons.length
        ? h("div",{class:"scan-items"},status.reasons.map(r=>h("div",{class:"scan-item"},
            h("span",{style:{color:r.sev==="bad"?"var(--danger)":"var(--warn)",flexShrink:"0"}},si[r.sev]),
            h("span",{},r.msg)
          )))
        : h("div",{class:"scan-item"},h("span",{style:"color:var(--a);flex-shrink:0"},"âœ“"),h("span",{},"No issues detected"))
    )
  );
}

function rBatchTab() {
  return h("div",{},
    h("div",{class:"sec-label"},"â—ˆ Batch CSV â†’ ZIP"),
    h("div",{style:"font-size:11px;color:rgba(255,255,255,.25);margin-bottom:12px;line-height:1.7"},
      "Format: ",h("span",{style:"color:rgba(184,244,0,.55);font-family:'Space Mono',monospace"},"label,url"),
      ` per line. Max ${BATCH_MAX_ROWS} rows. Uses current color + EC settings. Square modules for max reliability.`
    ),
    h("button",{class:"batch-drop",onClick:()=>document.getElementById("batch-inp")?.click()},
      h("span",{class:"ico"},"ğŸ“‹"),
      h("span",{class:"txt"},"Upload CSV file"),
      h("span",{class:"sub"},"or paste below")
    ),
    h("input",{id:"batch-inp",type:"file",accept:".csv,text/csv",style:"display:none",
      onChange:async e=>{
        const f=e.target.files?.[0]; if(!f) return;
        if(f.size>BATCH_MAX_BYTES){toast("CSV too large (max 5MB)","wn");return;}
        const text=await f.text(); e.target.value=""; runBatch(text);
      }
    }),
    h("div",{style:"margin-top:10px"},
      h("div",{class:"lbl"},"Paste CSV"),
      h("textarea",{placeholder:"homepage,https://example.com\nshop,https://shop.example.com",style:"min-height:72px",
        onBlur:e=>{if(e.target.value.trim()){runBatch(e.target.value);e.target.value="";}}
      })
    ),
    S.batchProgress ? h("div",{class:"batch-progress"},
      h("div",{class:"batch-txt"},`Generating ${S.batchProgress.done} / ${S.batchProgress.total}`),
      h("div",{class:"batch-bar-wrap"},
        h("div",{class:"batch-bar",style:{width:`${Math.round(S.batchProgress.done/S.batchProgress.total*100)}%`}})
      )
    ) : null,
    S.batchBlob ? h("div",{class:"batch-progress"},
      h("div",{class:"batch-txt",style:"color:rgba(184,244,0,.7)"},"âœ“ ZIP ready"),
      h("button",{class:"batch-dl",onClick:downloadBatch},"â¬‡ Download ZIP")
    ) : null
  );
}

/* â”€â”€ Stats bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function rQRStats(rawData) {
  if (!S.hasQR || !rawData.trim()) return null;
  const byteLen = new TextEncoder().encode(rawData).length;
  const effEC   = QRC.clampEC(S.ecLevel, S.logoSrc, S.logoSize);
  const maxCap  = QR_CAP[effEC]?.[S.qrVersion-1] || 0;
  const pct     = maxCap ? Math.round(byteLen/maxCap*100) : 0;
  const vCl     = S.qrVersion>25?"bad":S.qrVersion>15?"warn":"";
  const pCl     = pct>90?"bad":pct>70?"warn":"";

  const wrap = document.createElement("div"); wrap.className="qr-stats";
  const chips = [
    h("div",{class:`stat-chip ${vCl}`},"v",h("span",{class:"sv"},S.qrVersion)),
    h("div",{class:`stat-chip ${pCl}`},"cap ",h("span",{class:"sv"},pct+"%")),
    h("div",{class:"stat-chip"},"bytes ",h("span",{class:"sv"},byteLen)),
    h("div",{class:"stat-chip"},h("span",{class:"sv"},effEC)," EC"),
  ];
  if (S.finderOk===false) chips.push(h("div",{class:"stat-chip bad"},h("span",{class:"sv"},"âš ")," finder"));
  if (S.finderOk===true)  chips.push(h("div",{class:"stat-chip"},h("span",{class:"sv"},"âœ“")," finder"));
  chips.forEach(c=>wrap.appendChild(c));
  return wrap;
}

/* â”€â”€ Preview panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function rPreviewPanel(rawData) {
  const hasData = !!rawData.trim();

  // Update QR_MOUNT state without replacing it
  QR_MOUNT.className = (!hasData?"qr-mount empty":"qr-mount")+
    (S.verifyStatus==="pass"?" pass":S.verifyStatus==="fail"?" fail":"")+
    (S.lowlight?" lowlight":"");
  QR_MOUNT.style.background = hasData ? safeHex(S.bgColor,"") : "";

  // Scanline
  let sl = QR_MOUNT.querySelector(".scanline-wrap");
  if (S.verifyStatus==="checking"||S.verifyStatus==="loading") {
    if (!sl) {
      sl=document.createElement("div"); sl.className="scanline-wrap";
      const line=document.createElement("div"); line.className="scanline";
      sl.appendChild(line); QR_MOUNT.appendChild(sl);
    }
  } else { if(sl) sl.remove(); }

  // Empty hint
  let hint = QR_MOUNT.querySelector(".empty-hint");
  if (!hasData) {
    if (!hint) {
      hint=document.createElement("div"); hint.className="empty-hint";
      const big=document.createElement("div"); big.className="big"; big.textContent="â–£";
      const txt=document.createElement("div"); txt.className="txt"; txt.textContent="Enter data to generate";
      hint.appendChild(big); hint.appendChild(txt); QR_MOUNT.appendChild(hint);
    }
  } else { if(hint) hint.remove(); }

  const stats = rQRStats(rawData);

  return h("div",{class:"sec"},
    h("div",{class:"prev-hdr"},
      h("div",{class:"prev-title"},"â—ˆ Preview"),
      null  // verify badge injected by updateVerifyBadge()
    ),
    h("div",{id:"qr-mount-slot"}),
    stats,
    S.hasQR && hasData ? h("div",{},
      h("button",{
        class:"btn-ll"+(S.lowlight?" on":""),
        onClick:()=>update({lowlight:!S.lowlight}),
        title:"Simulate dim/bad phone camera"
      },S.lowlight?"ğŸ”† Low-light ON â€” click to disable":"ğŸŒ‘ Simulate low-light camera"),
      h("div",{class:"dl-row"},
        h("button",{class:"btn-main",onClick:dlQR},"â¬‡ Download PNG")
      ),
      h("div",{class:"cp-row"},
        h("button",{class:"btn-g"+(S.imgCopied?" done":""),onClick:copyImg},S.imgCopied?"âœ“ Copied!":"â˜ Copy Image"),
        h("button",{class:"btn-g"+(S.dataCopied?" done":""),onClick:()=>copyData(rawData)},S.dataCopied?"âœ“ Copied!":"â˜ Copy Data")
      ),
      (() => {
        const chip=document.createElement("div"); chip.className="data-chip";
        const pre=document.createElement("span"); pre.style.color="var(--a)"; pre.textContent="â–¶ ";
        chip.appendChild(pre); chip.appendChild(document.createTextNode(rawData));
        return chip;
      })(),
      h("div",{class:"cam-tip"},"ğŸ“± Most native phone cameras decode QR codes directly â€” no app needed")
    ) : null
  );
}

function rCustomize(status, rawData) {
  return h("div",{class:"sec"},
    h("div",{class:"sec-label"},"â—ˆ Customize"),
    h("div",{class:"ctabs"},
      ["style","colors","advanced","batch"].map(id=>h("button",{
        class:"ctab"+(S.customTab===id?" on":""),
        onClick:()=>update({customTab:id})
      },id[0].toUpperCase()+id.slice(1)))
    ),
    S.customTab==="style"    ? rStyleTab()             : null,
    S.customTab==="colors"   ? rColorsTab()            : null,
    S.customTab==="advanced" ? rAdvancedTab(status,rawData) : null,
    S.customTab==="batch"    ? rBatchTab()             : null,
  );
}

/* â”€â”€ Main render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _prevSig = null;
function render() {
  const root = document.getElementById("root"); if (!root) return;

  const rawData  = buildData(S.qrType, S.fields);
  const hasData  = !!rawData.trim();
  const byteLen  = new TextEncoder().encode(rawData).length;
  const status   = scanStatus(S.fgColor, S.bgColor, S.ecLevel, S.logoSrc?S.logoSize:0,
                              byteLen, S.hasMargin, S.qrVersion, S.finderOk);

  const sig = [S.qrType,S.customTab,S.dotStyle,S.eyeStyle,S.fgColor,S.bgColor,S.ecLevel,
               S.logoSrc?"y":"n",S.logoSize,S.hasMargin,status.level,hasData,S.hasQR,
               S.qrVersion,S.finderOk,S.printSize,S.printDPI,S.lowlight,
               S.batchProgress?"y":"n",S.batchBlob?"y":"n",
               Object.keys(S.fieldErrs).join(",")].join("|");

  // Always update cheap QR_MOUNT state
  QR_MOUNT.className = (!hasData?"qr-mount empty":"qr-mount")+
    (S.verifyStatus==="pass"?" pass":S.verifyStatus==="fail"?" fail":"")+
    (S.lowlight?" lowlight":"");
  QR_MOUNT.style.background = hasData ? safeHex(S.bgColor,"") : "";
  let sl=QR_MOUNT.querySelector(".scanline-wrap");
  if (S.verifyStatus==="checking"||S.verifyStatus==="loading"){
    if(!sl){sl=document.createElement("div");sl.className="scanline-wrap";const ln=document.createElement("div");ln.className="scanline";sl.appendChild(ln);QR_MOUNT.appendChild(sl);}
  } else {if(sl)sl.remove();}
  let hint=QR_MOUNT.querySelector(".empty-hint");
  if(!hasData){if(!hint){hint=document.createElement("div");hint.className="empty-hint";const b=document.createElement("div");b.className="big";b.textContent="â–£";const t=document.createElement("div");t.className="txt";t.textContent="Enter data to generate";hint.appendChild(b);hint.appendChild(t);QR_MOUNT.appendChild(hint);}}
  else{if(hint)hint.remove();}

  updateVerifyBadge();
  if (sig === _prevSig) return;
  _prevSig = sig;

  // Full rebuild
  const tree = document.createElement("div");
  tree.appendChild(rHeader());
  const main=document.createElement("div"); main.className="main";
  const grid=document.createElement("div"); grid.className="grid";

  const left=document.createElement("div");
  const typeSec=document.createElement("div"); typeSec.className="sec";
  typeSec.appendChild(rTypeSelector()); left.appendChild(typeSec);
  const formSec=document.createElement("div"); formSec.className="sec"; formSec.style.marginTop="14px";
  const fl=document.createElement("div"); fl.className="sec-label"; fl.textContent="â—ˆ Content";
  formSec.appendChild(fl); formSec.appendChild(FORM_EL); left.appendChild(formSec);
  left.appendChild(rCustomize(status, rawData));
  grid.appendChild(left);

  const right=document.createElement("div"); right.className="preview-wrap";
  right.appendChild(rPreviewPanel(rawData));
  grid.appendChild(right);

  main.appendChild(grid); tree.appendChild(main);
  root.innerHTML="";
  while(tree.firstChild) root.appendChild(tree.firstChild);

  const slot=document.getElementById("qr-mount-slot");
  if(slot) slot.replaceWith(QR_MOUNT);

  buildForm(FORM_EL);
  updateVerifyBadge();
}

/* â”€â”€ Verify badge (runs on every update, cheap) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function updateVerifyBadge() {
  const hdr = document.querySelector(".prev-hdr"); if(!hdr) return;
  let badge = hdr.querySelector(".vbadge");
  if (!S.verifyStatus) { if(badge) badge.remove(); return; }
  if (!badge) { badge=document.createElement("span"); hdr.appendChild(badge); }
  const map = {
    loading:  ["vbadge loading",  "âŸ³ loading verifierâ€¦"],
    checking: ["vbadge checking", "âŸ³ verifyingâ€¦"],
    pass:     ["vbadge pass",     "âœ“ verified"],
    fail:     ["vbadge fail",     "âš  verify failed"],
  };
  const [cls,txt] = map[S.verifyStatus]||["vbadge",""];
  badge.className=cls; badge.textContent=txt;

  // Disclaimer beneath QR mount
  const mount=document.getElementById("qr-mount"); if(!mount) return;
  let disc=document.getElementById("vdisc");
  if (S.verifyStatus==="pass") {
    if (!disc) {
      disc=document.createElement("div"); disc.id="vdisc";
      disc.style.cssText="font-size:10px;color:rgba(255,255,255,.16);text-align:center;margin-bottom:10px;font-family:'Space Mono',monospace;line-height:1.5;padding:0 4px";
      disc.textContent="Verified on B&W canvas. Real scan depends on print quality and lighting.";
      mount.insertAdjacentElement("afterend",disc);
    }
  } else { if(disc) disc.remove(); }
}

/* â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
render();
buildForm(FORM_EL);
if (Object.keys(S.fields).length > 0) triggerQR();
</script>
</body>
</html>
