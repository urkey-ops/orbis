<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>QR_studio</title>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;500;600;700;800&display=swap"/>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --a:#b8f400;
  --a10:rgba(184,244,0,.10);
  --a20:rgba(184,244,0,.20);
  --dark:#090b08;
  --card:#0f1210;
  --card2:#131714;
  --bord:rgba(184,244,0,.09);
  --bord2:rgba(255,255,255,.06);
  --mut:rgba(255,255,255,.30);
  --danger:#ff4455;
  --warn:#ffa040;
}
html{scroll-behavior:smooth}
body{background:var(--dark);color:#e4ebe0;font-family:'Syne',sans-serif;min-height:100vh;overflow-x:hidden}
::-webkit-scrollbar{width:3px}
::-webkit-scrollbar-thumb{background:var(--bord);border-radius:2px}

/* inputs */
input,textarea,select{
  font-family:inherit;background:rgba(255,255,255,.025);
  border:1px solid var(--bord2);border-radius:8px;
  color:#e4ebe0;padding:9px 12px;font-size:14px;width:100%;
  outline:none;transition:border-color .15s,box-shadow .15s;
}
input:focus,textarea:focus,select:focus{border-color:var(--a);box-shadow:0 0 0 3px rgba(184,244,0,.06)}
input::placeholder,textarea::placeholder{color:rgba(255,255,255,.16)}
option{background:#141a12}
textarea{resize:vertical;min-height:68px}
button{cursor:pointer;font-family:inherit;border:none;transition:all .15s}
button:active{transform:scale(.96)}
input[type=range]{padding:0;background:none;border:none;accent-color:var(--a);cursor:pointer;height:4px}
input[type=range]:focus{box-shadow:none;border:none}
input[type=color]{padding:2px;border:none;background:none;cursor:pointer;width:100%;height:100%}

/* animations */
@keyframes fadeUp{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:none}}
@keyframes toastIn{from{opacity:0;transform:translateX(28px)}to{opacity:1;transform:none}}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.25}}
@keyframes scanline{0%{top:-4px}100%{top:calc(100% + 4px)}}

/* layout */
header{
  position:sticky;top:0;z-index:100;
  border-bottom:1px solid var(--bord);
  background:rgba(9,11,8,.92);
  backdrop-filter:blur(20px);
  padding:0 24px;
}
.hdr-inner{max-width:1100px;margin:0 auto;height:54px;display:flex;align-items:center;justify-content:space-between}
.logo{display:flex;align-items:center;gap:9px;text-decoration:none}
.logo-box{width:28px;height:28px;background:var(--a);border-radius:6px;display:grid;place-items:center;font-size:13px;flex-shrink:0}
.logo-name{font-family:'Space Mono',monospace;font-weight:700;font-size:16px;letter-spacing:-1px;color:#e4ebe0}
.logo-name span{color:var(--a)}
.hdr-badge{font-family:'Space Mono',monospace;font-size:10px;color:rgba(184,244,0,.45);letter-spacing:2px;border:1px solid var(--bord);padding:4px 10px;border-radius:20px}

.main{max-width:1100px;margin:0 auto;padding:24px 24px 60px}
.grid{display:grid;grid-template-columns:1fr 360px;gap:16px;align-items:start}
@media(max-width:820px){.grid{grid-template-columns:1fr}}

/* section */
.sec{background:var(--card);border:1px solid var(--bord);border-radius:14px;padding:20px}
.sec+.sec{margin-top:14px}
.sec-label{font-family:'Space Mono',monospace;font-size:9px;font-weight:700;color:rgba(184,244,0,.38);letter-spacing:3px;text-transform:uppercase;margin-bottom:16px}

/* type selector */
.type-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:5px;margin-bottom:0}
@media(max-width:600px){.type-grid{grid-template-columns:repeat(4,1fr)}}
.type-btn{display:flex;flex-direction:column;align-items:center;gap:4px;padding:8px 4px;border-radius:9px;border:1px solid var(--bord2);background:transparent;color:var(--mut);font-size:11px;font-weight:600}
.type-btn .ico{font-size:16px}
.type-btn.on{border-color:var(--a);background:var(--a10);color:var(--a)}
.type-btn:hover:not(.on){border-color:rgba(255,255,255,.12);color:rgba(255,255,255,.6)}

/* form */
.lbl{font-family:'Space Mono',monospace;font-size:10px;font-weight:700;color:rgba(255,255,255,.24);letter-spacing:1.5px;text-transform:uppercase;margin-bottom:5px}
.fld{margin-bottom:12px}
.fld:last-child{margin-bottom:0}
.two{display:grid;grid-template-columns:1fr 1fr;gap:10px}

/* customize tabs */
.ctabs{display:flex;gap:2px;background:rgba(255,255,255,.025);border:1px solid rgba(255,255,255,.05);border-radius:8px;padding:3px;margin-bottom:16px}
.ctab{flex:1;padding:6px 0;border-radius:6px;border:none;font-family:'Space Mono',monospace;font-size:10px;font-weight:700;background:transparent;color:rgba(255,255,255,.26);text-transform:uppercase;letter-spacing:1px}
.ctab.on{background:var(--a);color:var(--dark)}

/* style options */
.shape-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px;margin-bottom:16px}
.shape-btn{padding:9px 5px;border-radius:9px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-size:11px;font-weight:600}
.shape-btn.on{border-color:var(--a);background:var(--a10);color:var(--a)}
.eye-row{display:flex;gap:6px}
.eye-btn{flex:1;padding:9px 5px;border-radius:9px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-size:11px;font-weight:600}
.eye-btn.on{border-color:var(--a);background:var(--a10);color:var(--a)}

/* colors */
.tpl-row{display:flex;gap:5px;flex-wrap:wrap;margin-bottom:16px}
.tpl{display:flex;align-items:center;gap:5px;padding:5px 10px;border-radius:7px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.4);font-size:11px;font-weight:600}
.tpl:hover{border-color:rgba(255,255,255,.18)}
.c-row{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
.c-lbl{font-size:13px;color:var(--mut)}
.c-ctrl{display:flex;align-items:center;gap:7px}
.swatch{width:28px;height:28px;border-radius:5px;border:2px solid rgba(255,255,255,.1);position:relative;overflow:hidden;cursor:pointer;flex-shrink:0}
.hex{width:78px;font-size:12px;font-family:'Space Mono',monospace;padding:4px 7px}
.tog-row{display:flex;align-items:center;gap:9px;margin-bottom:10px}
.tog{width:34px;height:18px;border-radius:9px;background:rgba(255,255,255,.08);position:relative;cursor:pointer;transition:background .18s;flex-shrink:0;border:none;padding:0;display:block}
.tog.on{background:var(--a)}
.tog-k{position:absolute;top:2px;left:2px;width:14px;height:14px;border-radius:50%;background:#fff;transition:left .18s;pointer-events:none}
.tog.on .tog-k{left:18px}
.tog-lbl{font-size:13px;color:var(--mut);cursor:pointer;user-select:none}

/* advanced */
.ec-row{display:flex;gap:6px;margin-bottom:5px}
.ecb{flex:1;padding:8px 0;border-radius:7px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-weight:700;font-size:13px;font-family:'Space Mono',monospace}
.ecb.on{border-color:var(--a);background:var(--a);color:var(--dark)}
.ecb.clamped{border-color:rgba(184,244,0,.4);color:var(--a)}
.ec-hint{font-size:10px;color:rgba(255,255,255,.16);font-family:'Space Mono',monospace;margin-bottom:18px}
.logo-up{width:100%;padding:16px;border-radius:9px;background:var(--a10);cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:6px;color:var(--a);outline:2px dashed var(--bord);border:none}
.logo-up:hover{background:var(--a20)}
.logo-prev{display:flex;align-items:center;gap:10px}
.logo-img{width:44px;height:44px;object-fit:contain;border-radius:7px;border:1px solid rgba(255,255,255,.08);background:#fff}
.logo-rm{width:26px;height:26px;border-radius:5px;border:none;background:rgba(255,68,85,.12);color:var(--danger);display:grid;place-items:center;font-size:16px;flex-shrink:0}

/* scan status â€” categorical only */
.scan-box{margin-top:18px;padding:13px 15px;border-radius:9px;border:1px solid}
.scan-box.good{border-color:rgba(184,244,0,.22);background:rgba(184,244,0,.04)}
.scan-box.caution{border-color:rgba(255,160,64,.22);background:rgba(255,160,64,.04)}
.scan-box.bad{border-color:rgba(255,68,85,.22);background:rgba(255,68,85,.04)}
.scan-hdr{display:flex;align-items:center;gap:8px;margin-bottom:8px}
.scan-dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
.scan-title{font-family:'Space Mono',monospace;font-size:10px;font-weight:700;letter-spacing:1px}
.scan-items{display:flex;flex-direction:column;gap:4px}
.scan-item{font-size:11px;color:rgba(255,255,255,.36);display:flex;align-items:flex-start;gap:6px;line-height:1.5}

/* quiet zone hint â€” phone camera specific */
.qz-notice{margin-top:10px;padding:8px 10px;border-radius:7px;background:rgba(184,244,0,.04);border:1px solid var(--bord);font-size:11px;color:rgba(255,255,255,.3);line-height:1.6}
.qz-notice strong{color:rgba(184,244,0,.6);font-weight:600}

/* preview panel */
.preview-wrap{position:sticky;top:68px}
.prev-hdr{display:flex;align-items:center;justify-content:space-between;margin-bottom:14px}
.prev-title{font-family:'Space Mono',monospace;font-size:9px;font-weight:700;color:rgba(184,244,0,.38);letter-spacing:3px;text-transform:uppercase}

/* QR mount â€” persistent, never recreated */
#qr-mount{
  display:flex;justify-content:center;align-items:center;
  min-height:280px;border-radius:11px;overflow:hidden;
  margin-bottom:14px;transition:box-shadow .25s,background .25s;
  position:relative;
}
#qr-mount.empty{background:rgba(255,255,255,.018);outline:2px dashed var(--bord)}
#qr-mount.pass{box-shadow:0 0 0 2px var(--a),0 0 32px rgba(184,244,0,.10)}
#qr-mount.fail{box-shadow:0 0 0 2px var(--danger),0 0 32px rgba(255,68,85,.08)}

/* scanline animation shown while verifying */
.scanline-wrap{position:absolute;inset:0;pointer-events:none;overflow:hidden;border-radius:11px}
.scanline{position:absolute;left:0;right:0;height:2px;background:linear-gradient(90deg,transparent,var(--a),transparent);animation:scanline 1.2s ease-in-out infinite;opacity:.7}

.empty-hint{text-align:center;color:rgba(184,244,0,.16)}
.empty-hint .big{font-size:48px;margin-bottom:10px;filter:grayscale(1)}
.empty-hint .txt{font-size:11px;font-family:'Space Mono',monospace;letter-spacing:1px}

/* verify badge */
.vbadge{font-size:10px;font-family:'Space Mono',monospace;display:flex;align-items:center;gap:5px}
.vbadge.pass{color:var(--a)}
.vbadge.fail{color:var(--danger)}
.vbadge.checking{color:rgba(184,244,0,.45)}

/* actions */
.dl-row{display:flex;gap:7px;margin-bottom:7px}
.btn-main{flex:1;padding:10px 0;border-radius:9px;border:none;background:var(--a);color:var(--dark);font-weight:700;font-size:13px;font-family:'Syne',sans-serif}
.btn-out{flex:1;padding:10px 0;border-radius:9px;border:1px solid var(--bord);background:transparent;color:var(--a);font-weight:700;font-size:13px}
.cp-row{display:flex;gap:7px;margin-bottom:12px}
.btn-g{flex:1;padding:8px 0;border-radius:9px;border:1px solid var(--bord2);background:rgba(255,255,255,.02);color:rgba(255,255,255,.34);font-size:12px;font-weight:600}
.btn-g.done{background:var(--a10);color:var(--a)}
.data-chip{padding:8px 10px;border-radius:7px;background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.05);font-size:10px;font-family:'Space Mono',monospace;color:rgba(255,255,255,.2);word-break:break-all;max-height:48px;overflow-y:auto;line-height:1.6}

/* phone camera tip */
.cam-tip{margin-top:12px;padding:10px 12px;border-radius:8px;border:1px solid var(--bord);background:var(--a10);font-size:11px;color:rgba(184,244,0,.55);font-family:'Space Mono',monospace;line-height:1.6;text-align:center}

/* toast */
#toasts{position:fixed;top:66px;right:18px;z-index:9999;display:flex;flex-direction:column;gap:7px;pointer-events:none}
.toast{padding:10px 15px;border-radius:10px;font-size:12px;font-weight:600;animation:toastIn .2s ease;display:flex;align-items:center;gap:7px;backdrop-filter:blur(16px);pointer-events:all}
.toast.ok{background:rgba(184,244,0,.13);border:1px solid rgba(184,244,0,.22);color:var(--a)}
.toast.er{background:rgba(255,68,85,.13);border:1px solid rgba(255,68,85,.22);color:var(--danger)}
.toast.wn{background:rgba(255,160,64,.13);border:1px solid rgba(255,160,64,.22);color:var(--warn)}
</style>
</head>
<body>
<div id="root"></div>
<div id="toasts"></div>

<script>
"use strict";
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   QR STUDIO v4  â€”  Encode-only. Lightning fast. Phone-camera optimized.

   Speed strategy:
   â€¢ qr-code-styling loaded once, instance reused via .update() â€” no flicker
   â€¢ MutationObserver replaces 900ms dead-wait timer for autoVerify
   â€¢ ZXing used ONLY for autoVerify (one lightweight read-back)
   â€¢ Form section is a persistent DOM node â€” inputs never recreated â†’ no focus loss
   â€¢ No decode tab, no decode UI, no drag/drop, no history

   Phone camera readability:
   â€¢ Default EC = H (30% data recovery â€” best for styled QR)
   â€¢ Minimum 16px quiet zone margin enforced
   â€¢ Gradient on dots DISABLED by default (hurts local contrast for scanners)
   â€¢ Contrast checked with QR-scanner thresholds, not WCAG text thresholds
   â€¢ Dot size warning if QR would be too dense for phone cameras
   â€¢ Canvas verify via ZXing â€” honest disclaimer shown always
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€ Script loader â€” promise-deduplicated â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const _sc = new Map();
function loadScript(src) {
  if (_sc.has(src)) return _sc.get(src);
  const p = new Promise((ok, fail) => {
    const s = document.createElement("script");
    s.src = src;
    s.onload = ok;
    s.onerror = () => { _sc.delete(src); fail(new Error("Load failed: " + src)); };
    document.head.appendChild(s);
  });
  _sc.set(src, p);
  return p;
}

/* â”€â”€ QR lib â€” styling first, raw fallback â€” loaded once â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _qlP = null;
function ensureQRLib() {
  if (!_qlP) _qlP = loadScript("https://unpkg.com/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js")
    .catch(() => loadScript("https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"))
    .catch(() => { throw new Error("No QR library available"); });
  return _qlP;
}

/* â”€â”€ ZXing â€” loaded once, used only for autoVerify â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _zxP = null;
function ensureZXing() {
  if (!_zxP) _zxP = loadScript("https://unpkg.com/@zxing/library@0.19.1/umd/index.min.js")
    .then(() => { if (!window.ZXing) throw new Error("ZXing unavailable"); return window.ZXing; })
    .catch(e => { _zxP = null; throw e; });
  return _zxP;
}

/* â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function toast(msg, type = "ok", ms = 2600) {
  const c = document.getElementById("toasts");
  const el = document.createElement("div");
  el.className = "toast " + type;
  el.innerHTML = `<span>${{ ok: "âœ“", er: "âœ•", wn: "âš " }[type] || "â€¢"}</span><span>${msg}</span>`;
  c.appendChild(el);
  setTimeout(() => { el.style.cssText = "opacity:0;transform:translateX(28px);transition:.18s"; setTimeout(() => el.remove(), 220); }, ms);
}

/* â”€â”€ Unified QR escaping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function qrEsc(v, mode = "vcard") {
  let s = (v || "").replace(/\\/g, "\\\\").replace(/;/g, "\\;").replace(/,/g, "\\,").replace(/"/g, '\\"');
  if (mode === "wifi") s = s.replace(/:/g, "\\:");
  return s;
}

/* â”€â”€ Data builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function buildData(type, f) {
  switch (type) {
    case "url": {
      let u = (f.url || "").trim();
      if (u && !/^https?:\/\//i.test(u)) u = "https://" + u;
      return u;
    }
    case "text":  return f.text || "";
    case "email": return `mailto:${f.email || ""}?subject=${encodeURIComponent(f.subject || "")}&body=${encodeURIComponent(f.body || "")}`;
    case "sms":   return `sms:${f.phone || ""}${f.message ? `?body=${encodeURIComponent(f.message)}` : ""}`;
    case "phone": return `tel:${f.phone || ""}`;
    case "wifi":  return `WIFI:T:${f.security || "WPA"};S:${qrEsc(f.ssid, "wifi")};P:${qrEsc(f.password, "wifi")};;`;
    case "vcard": {
      // FIX: join non-empty parts only â€” no leading space when first name missing
      const fn = [f.firstName, f.lastName].filter(Boolean).map(v => qrEsc(v)).join(" ");
      return [
        "BEGIN:VCARD", "VERSION:3.0",
        `FN:${fn}`,
        `N:${qrEsc(f.lastName || "")};${qrEsc(f.firstName || "")};;;`,
        `ORG:${qrEsc(f.org || "")}`,
        // TEL, EMAIL, URL: NOT vCard text fields â€” no escaping, just sanitize format
        `TEL:${(f.phone || "").replace(/[^\d+\-().\ ]/g, "")}`,
        `EMAIL:${(f.email || "").trim()}`,
        `URL:${(f.website || "").trim()}`,
        `ADR:;;${qrEsc(f.address || "")};;;;`,
        "END:VCARD"
      ].join("\n");
    }
    default: return "";
  }
}

/* â”€â”€ 3-digit hex expansion â†’ correct contrast math â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function expandHex(hex) {
  hex = (hex || "").trim().replace(/^#/, "");
  if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
  return hex.length === 6 ? "#" + hex : null;
}
function hexLum(hex) {
  const h = expandHex(hex); if (!h) return 0;
  const r = parseInt(h.slice(1,3),16)/255, g = parseInt(h.slice(3,5),16)/255, b = parseInt(h.slice(5,7),16)/255;
  const lin = x => x <= 0.03928 ? x/12.92 : Math.pow((x+0.055)/1.055, 2.4);
  return 0.2126*lin(r) + 0.7152*lin(g) + 0.0722*lin(b);
}
function cr(fg, bg) {
  const l1 = hexLum(fg), l2 = hexLum(bg);
  return (Math.max(l1, l2) + 0.05) / (Math.min(l1, l2) + 0.05);
}

/* â”€â”€ Categorical scan status (QR scanner thresholds, not WCAG) â”€â”€â”€â”€â”€â”€ */
function scanStatus(fg, bg, ecLevel, logoSize, dataLen, hasMargin, useGrad) {
  const ratio = cr(fg, bg);
  const reasons = [];
  let bad = 0, caution = 0;

  // QR scanner contrast thresholds are different from WCAG text
  // Phone cameras need ~3:1 minimum, work best above 4.5:1
  if (ratio < 2.5) { bad++; reasons.push({ sev:"bad", msg: `Contrast ${ratio.toFixed(1)}:1 â€” too low for most phone cameras` }); }
  else if (ratio < 4)  { caution++; reasons.push({ sev:"caution", msg: `Contrast ${ratio.toFixed(1)}:1 â€” may fail in poor lighting` }); }

  // Gradient hurts local contrast for scanners even if overall contrast is ok
  if (useGrad) { caution++; reasons.push({ sev:"caution", msg: "Gradient dots reduce local contrast â€” phone cameras prefer solid foreground" }); }

  // EC + logo
  if (logoSize > 0 && ecLevel === "L") { bad++; reasons.push({ sev:"bad", msg: "Logo with L correction will be unreadable â€” use H" }); }
  else if (logoSize > 0 && ecLevel === "M") { caution++; reasons.push({ sev:"caution", msg: "Logo with M correction is risky â€” use Q or H" }); }
  if (logoSize > 30) { caution++; reasons.push({ sev:"caution", msg: "Logo covers >30% â€” data may be obscured" }); }

  // Dense data
  if (dataLen > 300) { caution++; reasons.push({ sev:"caution", msg: "Long data creates dense modules â€” test carefully on phone" }); }

  // Quiet zone â€” critical for phone camera detection
  if (!hasMargin) { bad++; reasons.push({ sev:"bad", msg: "No quiet zone â€” phone cameras need white border to locate the QR" }); }

  const level = bad > 0 ? "bad" : caution > 0 ? "caution" : "good";
  return { level, label: { good:"Camera Ready", caution:"Some Concerns", bad:"Will Likely Fail" }[level], reasons };
}

/* â”€â”€ localStorage â€” quota-guarded â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function lsGet(k, fb) { try { const v = localStorage.getItem(k); return v ? JSON.parse(v) : fb; } catch { return fb; } }
function lsSet(k, v) { try { localStorage.setItem(k, JSON.stringify(v)); } catch(e) { if (e.name==="QuotaExceededError"||e.code===22) toast("Storage full","wn"); } }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STATE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const S = {
  qrType: "url",
  fields: lsGet("qrs_fields_url", {}),
  dotType: "square",
  eyeRadius: "square",
  fgColor: "#b8f400",
  bgColor: "#0c0f0a",
  useGrad: false,
  gradEnd: "#00ff88",
  ecLevel: "H",       // Default H â€” best for phone camera reliability
  logoSrc: null,
  logoSize: 20,
  hasMargin: true,
  customTab: "style",
  verifyStatus: null, // null | "checking" | "pass" | "fail"
  imgCopied: false,
  dataCopied: false,
};

/* â”€â”€ Reactive core â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _raf = false;
function update(patch) {
  Object.assign(S, typeof patch === "function" ? patch(S) : patch);
  if (!_raf) { _raf = true; requestAnimationFrame(() => { render(); _raf = false; }); }
}

/* â”€â”€ h() â€” correct property setting, cursor-safe â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function h(tag, attrs = {}, ...kids) {
  const el = document.createElement(tag);
  for (const [k, v] of Object.entries(attrs)) {
    if (v === null || v === undefined || v === false) continue;
    if (k === "class")   el.className = v;
    else if (k === "style" && typeof v === "object") Object.assign(el.style, v);
    else if (k === "value")    el.value = v;          // property, not attribute
    else if (k === "checked")  el.checked = !!v;
    else if (k === "selected") el.selected = !!v;
    else if (k === "disabled") el.disabled = !!v;
    else if (k.startsWith("on") && typeof v === "function") el.addEventListener(k.slice(2).toLowerCase(), v);
    else el.setAttribute(k, v);
  }
  for (const c of kids.flat(Infinity)) {
    if (c == null || c === false) continue;
    el.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
  }
  return el;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   QRController â€” canvas lifecycle fully decoupled from UI render
   â€¢ Owns #qr-mount contents
   â€¢ Uses .update() to avoid flicker when only options change
   â€¢ MutationObserver to detect canvas-ready â€” no setTimeout dead-wait
   â€¢ EC invariant enforced here, at generation time
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QRC = (() => {
  let _inst = null;
  let _lastSig = null;
  let _obs = null;       // MutationObserver for canvas-ready detection

  // EC invariant: logo requires minimum error correction
  function clampEC(ec, logoSrc, logoSize) {
    if (!logoSrc || logoSize === 0) return ec;
    if (ec === "L") return "H";
    if (ec === "M" && logoSize > 15) return "H";
    if (ec === "M") return "Q";
    return ec;
  }

  function mount() { return document.getElementById("qr-mount"); }

  function sig(o) {
    return [o.data, o.dotType, o.eyeRadius, o.fgColor, o.bgColor, o.useGrad, o.gradEnd, o.ecLevel, o.logoSrc, o.logoSize, o.hasMargin].join("|");
  }

  // Wait for canvas to appear in mount using MutationObserver
  // Replaces arbitrary 900ms setTimeout â€” fires within one paint frame
  function waitForCanvas(el) {
    return new Promise(resolve => {
      const existing = el.querySelector("canvas");
      if (existing) { resolve(existing); return; }
      if (_obs) _obs.disconnect();
      _obs = new MutationObserver(() => {
        const c = el.querySelector("canvas");
        if (c) { _obs.disconnect(); _obs = null; resolve(c); }
      });
      _obs.observe(el, { childList: true, subtree: true });
      // Safety timeout: if canvas never appears (SVG-only path), resolve anyway
      setTimeout(() => { if (_obs) { _obs.disconnect(); _obs = null; } resolve(null); }, 3000);
    });
  }

  async function generate(opts) {
    const el = mount(); if (!el) return;
    const effectiveEC = clampEC(opts.ecLevel, opts.logoSrc, opts.logoSize);
    const s = sig({ ...opts, ecLevel: effectiveEC });
    if (s === _lastSig) return;
    _lastSig = s;

    update({ verifyStatus: "checking" });

    try { await ensureQRLib(); } catch (e) { toast("QR library load failed", "er"); update({ verifyStatus: null }); return; }

    const qOpts = {
      width: 400, height: 400,
      data: opts.data,
      dotsOptions: opts.useGrad
        ? { type: opts.dotType, gradient: { type: "linear", rotation: 0.8, colorStops: [{ offset: 0, color: opts.fgColor }, { offset: 1, color: opts.gradEnd }] } }
        : { type: opts.dotType, color: opts.fgColor },
      cornersSquareOptions: {
        type: opts.eyeRadius === "dot" ? "dot" : opts.eyeRadius === "extra-rounded" ? "extra-rounded" : "square",
        color: opts.fgColor
      },
      cornersDotOptions: { type: opts.eyeRadius === "dot" ? "dot" : "square", color: opts.fgColor },
      backgroundOptions: { color: opts.bgColor },
      qrOptions: { errorCorrectionLevel: effectiveEC },
      margin: opts.hasMargin ? 16 : 0,  // 16px quiet zone â€” minimum for phone cameras
      ...(opts.logoSrc ? { image: opts.logoSrc, imageOptions: { imageSize: opts.logoSize / 100, margin: 5, crossOrigin: "anonymous" } } : {}),
    };

    if (window.QRCodeStyling) {
      if (_inst) {
        _inst.update(qOpts); // in-place update â€” no flicker, no DOM thrash
      } else {
        el.innerHTML = "";
        _inst = new window.QRCodeStyling(qOpts);
        _inst.append(el);
      }
    } else if (window.QRCode) {
      el.innerHTML = ""; _inst = null;
      new window.QRCode(el, {
        text: opts.data, width: 320, height: 320,
        colorDark: opts.fgColor, colorLight: opts.bgColor,
        correctLevel: window.QRCode.CorrectLevel[effectiveEC] || window.QRCode.CorrectLevel.H,
      });
    }

    // MutationObserver-based verify â€” fires as soon as canvas appears, not after 900ms
    waitForCanvas(el).then(canvas => {
      if (canvas) autoVerify(opts.data, canvas);
      else update({ verifyStatus: null });
    });
  }

  function clear() {
    const el = mount(); if (!el) return;
    if (_obs) { _obs.disconnect(); _obs = null; }
    _inst = null; _lastSig = null;
    el.innerHTML = "";
    update({ verifyStatus: null });
  }

  function getInstance() { return _inst; }
  function getClampEC(ec, logoSrc, logoSize) { return clampEC(ec, logoSrc, logoSize); }

  return { generate, clear, getInstance, clampEC: getClampEC };
})();

/* â”€â”€ autoVerify â€” compares decoded === expected, always shows disclaimer */
async function autoVerify(expectedData, canvas) {
  try {
    const ZXing = await ensureZXing();
    const img = new Image();
    img.src = canvas.toDataURL("image/png");
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });
    const reader = new ZXing.BrowserQRCodeReader();
    const result = await reader.decodeFromImageElement(img).catch(() => null);
    const decoded = result ? result.getText() : null;
    // Exact comparison â€” not just truthy
    update({ verifyStatus: decoded === expectedData ? "pass" : "fail" });
  } catch {
    update({ verifyStatus: null });
  }
}

/* â”€â”€ Download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function dlQR(fmt) {
  const inst = QRC.getInstance();
  if (!inst) {
    const c = document.getElementById("qr-mount")?.querySelector("canvas");
    if (!c) { toast("Generate a QR first", "wn"); return; }
    const a = document.createElement("a"); a.href = c.toDataURL(); a.download = "qrcode.png"; a.click();
    return;
  }
  inst.download({ name: "qrcode", extension: fmt });
}

/* â”€â”€ Copy image â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function copyImg() {
  const c = document.getElementById("qr-mount")?.querySelector("canvas");
  if (!c) { toast("Generate a QR first", "wn"); return; }
  c.toBlob(async blob => {
    try {
      await navigator.clipboard.write([new ClipboardItem({ "image/png": blob })]);
      update({ imgCopied: true }); setTimeout(() => update({ imgCopied: false }), 2000);
      toast("Image copied", "ok");
    } catch { toast("Clipboard denied â€” use Download instead", "er"); }
  });
}

/* â”€â”€ Copy data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
async function copyData(raw) {
  try {
    await navigator.clipboard.writeText(raw);
    update({ dataCopied: true }); setTimeout(() => update({ dataCopied: false }), 2000);
    toast("Copied", "ok");
  } catch { toast("Clipboard write failed", "er"); }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CONSTANTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const QR_TYPES = [
  { id:"url",   label:"URL",   icon:"ðŸ”—" }, { id:"text",  label:"Text",  icon:"ðŸ“" },
  { id:"email", label:"Email", icon:"âœ‰ï¸" }, { id:"sms",   label:"SMS",   icon:"ðŸ’¬" },
  { id:"phone", label:"Phone", icon:"ðŸ“ž" }, { id:"wifi",  label:"WiFi",  icon:"ðŸ“¶" },
  { id:"vcard", label:"vCard", icon:"ðŸ‘¤" },
];
const DOT_TYPES   = ["square","dots","rounded","extra-rounded","classy","classy-rounded"];
const DOT_LABELS  = { square:"Square", dots:"Dots", rounded:"Rounded", "extra-rounded":"X-Round", classy:"Classy", "classy-rounded":"Classy+" };
const EYE_RADII   = ["square","dot","extra-rounded"];
const EYE_LABELS  = { square:"Square", dot:"Dot", "extra-rounded":"Round" };
const EC_LEVELS   = ["L","M","Q","H"];
const TEMPLATES   = [
  { name:"Acid",      bg:"#0c0f0a", fg:"#b8f400" }, { name:"Obsidian", bg:"#0d0d0d", fg:"#ffffff" },
  { name:"Blueprint", bg:"#0a1628", fg:"#4da6ff" }, { name:"Ember",    bg:"#1a0800", fg:"#ff6b35" },
  { name:"Sakura",    bg:"#1a0d12", fg:"#ff8fab" }, { name:"Matrix",   bg:"#001a00", fg:"#00ff41" },
  { name:"Chalk",     bg:"#fafaf8", fg:"#1a1a1a" }, { name:"Gold",     bg:"#0f0c00", fg:"#ffd700" },
];

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PERSISTENT ELEMENTS â€” never recreated by render()
   This is how we fix focus loss: form + QR mount are stable DOM nodes.
   render() patches their attributes; never replaces the elements.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

// Persistent QR mount
const QR_MOUNT = (() => {
  const el = document.createElement("div");
  el.id = "qr-mount";
  el.className = "qr-mount empty";
  el.innerHTML = `<div class="empty-hint"><div class="big">â–£</div><div class="txt">Enter data to generate</div></div>`;
  return el;
})();

// Persistent form container â€” children updated via patchForm(), not replaced
const FORM_EL = document.createElement("div");
FORM_EL.id = "form-container";

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   FORM PATCHING â€” updates inputs in-place, never replaces elements
   This is the fix for focus loss. We compare current DOM to desired
   state and only change what differs.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function patchInput(container, key, label, placeholder, type = "text") {
  let wrap = container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap = document.createElement("div");
    wrap.className = "fld";
    wrap.setAttribute("data-key", key);
    const lbl = document.createElement("div"); lbl.className = "lbl"; lbl.textContent = label;
    const inp = document.createElement("input");
    inp.type = type; inp.placeholder = placeholder;
    inp.addEventListener("input", e => {
      const newFields = { ...S.fields, [key]: e.target.value };
      S.fields = newFields; // Direct mutation â€” we're inside the input handler, rAF will pick it up
      lsSet("qrs_fields_" + S.qrType, newFields);
      scheduleQR();
    });
    wrap.appendChild(lbl); wrap.appendChild(inp);
    container.appendChild(wrap);
  }
  // Patch only if value differs from state (don't touch focused input)
  const inp = wrap.querySelector("input");
  if (document.activeElement !== inp && inp.value !== (S.fields[key] || "")) {
    inp.value = S.fields[key] || "";
  }
  inp.type = type;
  inp.placeholder = placeholder;
  wrap.querySelector(".lbl").textContent = label;
}

function patchTextarea(container, key, label, placeholder) {
  let wrap = container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap = document.createElement("div");
    wrap.className = "fld";
    wrap.setAttribute("data-key", key);
    const lbl = document.createElement("div"); lbl.className = "lbl"; lbl.textContent = label;
    const ta = document.createElement("textarea");
    ta.placeholder = placeholder;
    ta.addEventListener("input", e => {
      S.fields = { ...S.fields, [key]: e.target.value };
      lsSet("qrs_fields_" + S.qrType, S.fields);
      scheduleQR();
    });
    wrap.appendChild(lbl); wrap.appendChild(ta);
    container.appendChild(wrap);
  }
  const ta = wrap.querySelector("textarea");
  if (document.activeElement !== ta && ta.value !== (S.fields[key] || "")) {
    ta.value = S.fields[key] || "";
  }
  ta.placeholder = placeholder;
}

function patchSelect(container, key, label, options) {
  let wrap = container.querySelector(`[data-key="${key}"]`);
  if (!wrap) {
    wrap = document.createElement("div");
    wrap.className = "fld";
    wrap.setAttribute("data-key", key);
    const lbl = document.createElement("div"); lbl.className = "lbl"; lbl.textContent = label;
    const sel = document.createElement("select");
    options.forEach(o => { const op = document.createElement("option"); op.value = op.textContent = o; sel.appendChild(op); });
    sel.addEventListener("change", e => {
      S.fields = { ...S.fields, [key]: e.target.value };
      lsSet("qrs_fields_" + S.qrType, S.fields);
      scheduleQR();
    });
    wrap.appendChild(lbl); wrap.appendChild(sel);
    container.appendChild(wrap);
  }
  const sel = wrap.querySelector("select");
  sel.value = S.fields[key] || options[0];
}

function buildForm(container) {
  // Remove any fields not needed for current type
  const needed = getNeededKeys(S.qrType);
  [...container.querySelectorAll("[data-key]")].forEach(el => {
    if (!needed.includes(el.dataset.key)) el.remove();
  });

  // Also remove two-col wrappers if switching away from vcard
  if (S.qrType !== "vcard") {
    const tc = container.querySelector(".two"); if (tc) tc.remove();
  }

  switch (S.qrType) {
    case "url":
      patchInput(container, "url", "Website URL", "https://example.com", "url"); break;
    case "text":
      patchTextarea(container, "text", "Text Content", "Any text, code, messageâ€¦"); break;
    case "email":
      patchInput(container, "email", "Email", "you@example.com", "email");
      patchInput(container, "subject", "Subject", "Subject line");
      patchTextarea(container, "body", "Body", "Messageâ€¦"); break;
    case "sms":
      patchInput(container, "phone", "Phone Number", "+1 555 000 0000", "tel");
      patchTextarea(container, "message", "Message", "SMS bodyâ€¦"); break;
    case "phone":
      patchInput(container, "phone", "Phone Number", "+1 555 000 0000", "tel"); break;
    case "wifi":
      patchInput(container, "ssid", "Network SSID", "MyWiFiNetwork");
      patchInput(container, "password", "Password", "WiFi password", "password");
      patchSelect(container, "security", "Security", ["WPA","WPA2","WEP","None"]); break;
    case "vcard":
      // Two-column name row
      let twoCol = container.querySelector(".two");
      if (!twoCol) {
        twoCol = document.createElement("div");
        twoCol.className = "two";
        container.insertBefore(twoCol, container.firstChild);
      }
      // Check keys exist inside twoCol specifically
      const fnNeeded = ["firstName","lastName"];
      [...twoCol.querySelectorAll("[data-key]")].forEach(el => { if (!fnNeeded.includes(el.dataset.key)) el.remove(); });
      patchInput(twoCol, "firstName", "First Name", "John");
      patchInput(twoCol, "lastName", "Last Name", "Doe");
      patchInput(container, "org", "Organization", "Company Name");
      patchInput(container, "phone", "Phone", "+1 555 000 0000", "tel");
      patchInput(container, "email", "Email", "john@example.com", "email");
      patchInput(container, "website", "Website", "https://example.com", "url");
      patchInput(container, "address", "Address", "123 Main St, City"); break;
  }
}

function getNeededKeys(type) {
  const map = {
    url:["url"], text:["text"], email:["email","subject","body"],
    sms:["phone","message"], phone:["phone"], wifi:["ssid","password","security"],
    vcard:["firstName","lastName","org","phone","email","website","address"]
  };
  return map[type] || [];
}

/* â”€â”€ Debounced QR generation â€” triggered by form changes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _qrTimer = null;
function scheduleQR() {
  if (_qrTimer) clearTimeout(_qrTimer);
  _qrTimer = setTimeout(triggerQR, 180); // 180ms debounce on typing
}

function triggerQR() {
  _qrTimer = null;
  const raw = buildData(S.qrType, S.fields);
  if (!raw.trim()) { QRC.clear(); return; }
  QRC.generate({
    data: raw, dotType: S.dotType, eyeRadius: S.eyeRadius,
    fgColor: S.fgColor, bgColor: S.bgColor,
    useGrad: S.useGrad, gradEnd: S.gradEnd,
    ecLevel: S.ecLevel, logoSrc: S.logoSrc,
    logoSize: S.logoSize, hasMargin: S.hasMargin,
  });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   RENDER â€” UI skeleton only. Form inputs never replaced. QR never touched.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const tog = (on, onClick) => h("button", { class: "tog" + (on ? " on" : ""), onClick }, h("div", { class: "tog-k" }));

function rHeader() {
  return h("header", {}, h("div", { class: "hdr-inner" },
    h("div", { class: "logo" },
      h("div", { class: "logo-box" }, "â–£"),
      h("div", { class: "logo-name" }, "QR", h("span", {}, "_"), "studio")
    ),
    h("div", { class: "hdr-badge" }, "ENCODE")
  ));
}

function rTypeSelector() {
  return h("div", {}, h("div", { class: "sec-label", style: "margin-bottom:12px" }, "â—ˆ Content Type"),
    h("div", { class: "type-grid" },
      QR_TYPES.map(t => h("button", {
        class: "type-btn" + (S.qrType === t.id ? " on" : ""),
        onClick: () => {
          if (S.qrType === t.id) return;
          S.fields = lsGet("qrs_fields_" + t.id, {});
          update({ qrType: t.id, fields: S.fields });
          // Rebuild form for new type
          setTimeout(() => { buildForm(FORM_EL); triggerQR(); }, 0);
        }
      }, h("span", { class: "ico" }, t.icon), t.label))
    )
  );
}

function rStyleTab() {
  return h("div", {},
    h("div", { class: "lbl" }, "Module Shape"),
    h("div", { class: "shape-grid" },
      DOT_TYPES.map(d => h("button", { class: "shape-btn" + (S.dotType === d ? " on" : ""), onClick: () => { update({ dotType: d }); triggerQR(); } }, DOT_LABELS[d]))
    ),
    h("div", { class: "lbl" }, "Eye Style"),
    h("div", { class: "eye-row" },
      EYE_RADII.map(e => h("button", { class: "eye-btn" + (S.eyeRadius === e ? " on" : ""), onClick: () => { update({ eyeRadius: e }); triggerQR(); } }, EYE_LABELS[e]))
    )
  );
}

function rColorsTab() {
  const cRow = (label, val, onChange) => h("div", { class: "c-row" },
    h("span", { class: "c-lbl" }, label),
    h("div", { class: "c-ctrl" },
      h("div", { class: "swatch", style: { background: val } },
        h("input", { type: "color", value: val, onInput: e => { onChange(e.target.value); triggerQR(); } })
      ),
      h("input", { type: "text", class: "hex", value: val,
        onInput: e => { if (/^#[0-9a-fA-F]{0,6}$/.test(e.target.value)) { onChange(e.target.value); triggerQR(); } }
      })
    )
  );
  return h("div", {},
    h("div", { class: "lbl" }, "Templates"),
    h("div", { class: "tpl-row" },
      TEMPLATES.map(t => h("button", { class: "tpl",
        onClick: () => { update({ bgColor: t.bg, fgColor: t.fg, useGrad: false }); triggerQR(); }
      }, h("div", { style: { width:"12px",height:"12px",borderRadius:"3px",background:t.fg,flexShrink:"0" } }), t.name))
    ),
    cRow("Foreground", S.fgColor, v => update({ fgColor: v })),
    cRow("Background", S.bgColor, v => update({ bgColor: v })),
    h("div", { class: "tog-row" },
      tog(S.useGrad, () => { update({ useGrad: !S.useGrad }); triggerQR(); }),
      h("span", { class: "tog-lbl", onClick: () => { update({ useGrad: !S.useGrad }); triggerQR(); } }, "Gradient mode")
    ),
    S.useGrad ? cRow("Gradient End", S.gradEnd, v => update({ gradEnd: v })) : null,
    // Phone camera warning about gradients
    S.useGrad ? h("div", { class: "qz-notice" }, "âš  Gradients reduce local dot contrast. Phone cameras may struggle. Solid foreground is always more reliable.") : null
  );
}

function rAdvancedTab(status) {
  const dc = { good:"var(--a)", caution:"var(--warn)", bad:"var(--danger)" };
  const si = { good:"âœ“", caution:"âš ", bad:"âœ•" };
  const effEC = QRC.clampEC(S.ecLevel, S.logoSrc, S.logoSize);

  return h("div", {},
    h("div", { class: "lbl" }, "Error Correction"),
    h("div", { class: "ec-row" },
      EC_LEVELS.map(l => {
        const isSelected = S.ecLevel === l;
        const isClamped  = effEC !== S.ecLevel && l === effEC;
        return h("button", {
          class: "ecb" + (isSelected ? " on" : "") + (isClamped && !isSelected ? " clamped" : ""),
          title: isClamped && !isSelected ? "Auto-upgraded by logo requirement" : "",
          onClick: () => { update({ ecLevel: l }); triggerQR(); }
        }, l + (isClamped && !isSelected ? "â†‘" : ""));
      })
    ),
    h("div", { class: "ec-hint" }, "L 7%  M 15%  Q 25%  H 30% â€” H recommended for styled QR"),

    h("div", { class: "lbl" }, "Logo / Icon"),
    S.logoSrc
      ? h("div", { class: "logo-prev" },
          h("img", { class: "logo-img", src: S.logoSrc }),
          h("div", { style: "flex:1" },
            h("div", { style: "font-size:11px;color:var(--mut);margin-bottom:5px" }, `Size: ${S.logoSize}%`),
            h("input", { type: "range", min: 10, max: 35, value: S.logoSize, style: "width:100%",
              onInput: e => { update({ logoSize: +e.target.value }); triggerQR(); }
            })
          ),
          h("button", { class: "logo-rm", onClick: () => { update({ logoSrc: null, logoSize: 20 }); triggerQR(); } }, "Ã—")
        )
      : h("button", { class: "logo-up", onClick: () => document.getElementById("logo-inp")?.click() },
          h("span", { style: "font-size:20px" }, "â¬†"),
          h("span", { style: "font-size:13px;font-weight:600" }, "Upload Logo"),
          h("span", { style: "font-size:10px;color:rgba(184,244,0,.35)" }, "Use H error correction with logos")
        ),
    h("input", { id: "logo-inp", type: "file", accept: "image/*", style: "display:none",
      onChange: e => {
        const file = e.target.files?.[0]; if (!file) return;
        const r = new FileReader();
        r.onload = ev => { update({ logoSrc: ev.target.result, ecLevel: "H" }); triggerQR(); };
        r.readAsDataURL(file);
      }
    }),

    h("div", { style: "margin-top:14px;display:flex;align-items:center;gap:9px;margin-bottom:16px" },
      tog(S.hasMargin, () => { update({ hasMargin: !S.hasMargin }); triggerQR(); }),
      h("span", { class: "tog-lbl", onClick: () => { update({ hasMargin: !S.hasMargin }); triggerQR(); } }, "Quiet zone margin")
    ),

    // Phone camera specific quiet zone tip
    h("div", { class: "qz-notice" },
      h("strong", {}, "Phone camera tip: "),
      "Quiet zone (white border) is how scanners locate the QR. Without it, scan fails reliably. Keep margin ON."
    ),

    // Categorical status
    h("div", { class: "scan-box " + status.level },
      h("div", { class: "scan-hdr" },
        h("div", { class: "scan-dot", style: { background: dc[status.level] } }),
        h("div", { class: "scan-title", style: { color: dc[status.level] } }, status.label)
      ),
      status.reasons.length > 0
        ? h("div", { class: "scan-items" },
            status.reasons.map(r => h("div", { class: "scan-item" },
              h("span", { style: { color: r.sev==="bad"?"var(--danger)":"var(--warn)", flexShrink:"0" } }, si[r.sev]),
              h("span", {}, r.msg)
            ))
          )
        : h("div", { class: "scan-item" },
            h("span", { style: "color:var(--a);flex-shrink:0" }, "âœ“"),
            h("span", {}, "No camera readability issues detected")
          )
    )
  );
}

function rPreviewPanel(rawData) {
  const hasData = !!rawData.trim();
  const hasInst = !!QRC.getInstance();

  // Update persistent QR_MOUNT class and bg without replacing it
  QR_MOUNT.className = (!hasData ? "qr-mount empty" : "qr-mount") +
    (S.verifyStatus === "pass" ? " pass" : S.verifyStatus === "fail" ? " fail" : "");
  QR_MOUNT.style.background = hasData ? S.bgColor : "";

  // Show/hide empty hint
  let hint = QR_MOUNT.querySelector(".empty-hint");
  if (!hasData) {
    if (!hint) {
      hint = document.createElement("div"); hint.className = "empty-hint";
      hint.innerHTML = `<div class="big">â–£</div><div class="txt">Enter data to generate</div>`;
      // Remove scanline if any
      const sl = QR_MOUNT.querySelector(".scanline-wrap"); if(sl) sl.remove();
      QR_MOUNT.appendChild(hint);
    }
  } else {
    if (hint) hint.remove();
  }

  // Scanline while verifying
  let slWrap = QR_MOUNT.querySelector(".scanline-wrap");
  if (S.verifyStatus === "checking") {
    if (!slWrap) {
      slWrap = document.createElement("div"); slWrap.className = "scanline-wrap";
      slWrap.innerHTML = `<div class="scanline"></div>`;
      QR_MOUNT.appendChild(slWrap);
    }
  } else { if (slWrap) slWrap.remove(); }

  let vBadge = null;
  if (S.verifyStatus === "checking") vBadge = h("span", { class: "vbadge checking" }, "âŸ³ verifyingâ€¦");
  else if (S.verifyStatus === "pass") vBadge = h("span", { class: "vbadge pass" }, "âœ“ canvas decoded");
  else if (S.verifyStatus === "fail") vBadge = h("span", { class: "vbadge fail" }, "âš  verify failed");

  return h("div", { class: "sec" },
    h("div", { class: "prev-hdr" },
      h("div", { class: "prev-title" }, "â—ˆ Preview"),
      vBadge
    ),
    // QR_MOUNT is inserted here by render() transplant logic
    h("div", { id: "qr-mount-slot" }),
    // Always show verify disclaimer when pass badge is visible
    S.verifyStatus === "pass"
      ? h("div", { style: "font-size:10px;color:rgba(255,255,255,.18);text-align:center;margin-bottom:10px;font-family:'Space Mono',monospace;line-height:1.5" },
          "Canvas decoded OK. Real scan depends on print quality + lighting."
        )
      : null,
    hasData && hasInst ? h("div", {},
      h("div", { class: "dl-row" },
        h("button", { class: "btn-main", onClick: () => dlQR("png") }, "â¬‡ Download PNG"),
        h("button", { class: "btn-out",  onClick: () => dlQR("svg") }, "â¬‡ SVG")
      ),
      h("div", { class: "cp-row" },
        h("button", { class: "btn-g" + (S.imgCopied ? " done" : ""), onClick: copyImg }, S.imgCopied ? "âœ“ Copied!" : "âŽ˜ Copy Image"),
        h("button", { class: "btn-g" + (S.dataCopied ? " done" : ""), onClick: () => copyData(rawData) }, S.dataCopied ? "âœ“ Copied!" : "âŽ˜ Copy Data")
      ),
      h("div", { class: "data-chip" }, h("span", { style: "color:var(--a)" }, "â–¶ "), rawData),
      h("div", { class: "cam-tip" }, "ðŸ“± Point phone camera directly at QR â€” most native cameras decode without an app")
    ) : null
  );
}

function rCustomize(status) {
  return h("div", { class: "sec" },
    h("div", { class: "sec-label" }, "â—ˆ Customize"),
    h("div", { class: "ctabs" },
      ["style","colors","advanced"].map(id => h("button", {
        class: "ctab" + (S.customTab === id ? " on" : ""),
        onClick: () => update({ customTab: id })
      }, id[0].toUpperCase() + id.slice(1)))
    ),
    S.customTab === "style"    ? rStyleTab() : null,
    S.customTab === "colors"   ? rColorsTab() : null,
    S.customTab === "advanced" ? rAdvancedTab(status) : null
  );
}

/* â”€â”€ Main render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _prevRenderSig = null;

function render() {
  const root = document.getElementById("root");
  if (!root) return;

  const rawData = buildData(S.qrType, S.fields);
  const hasData = !!rawData.trim();
  const status = scanStatus(S.fgColor, S.bgColor, S.ecLevel, S.logoSrc ? S.logoSize : 0, rawData.length, S.hasMargin, S.useGrad);

  // Render signature â€” skip full rebuild if only verify status changed
  const uiSig = [S.qrType, S.customTab, S.dotType, S.eyeRadius, S.fgColor, S.bgColor, S.useGrad, S.gradEnd, S.ecLevel, S.logoSrc?"y":"n", S.logoSize, S.hasMargin, status.level, hasData, !!QRC.getInstance()].join("|");
  const shouldRebuild = uiSig !== _prevRenderSig;

  // Always update QR_MOUNT state (class, bg, scanline, verify badge)
  // This is cheap and handles verify status changes without full rebuild
  QR_MOUNT.className = (!hasData ? "qr-mount empty" : "qr-mount") +
    (S.verifyStatus === "pass" ? " pass" : S.verifyStatus === "fail" ? " fail" : "");
  QR_MOUNT.style.background = hasData ? S.bgColor : "";
  let slWrap = QR_MOUNT.querySelector(".scanline-wrap");
  if (S.verifyStatus === "checking") {
    if (!slWrap) { slWrap = document.createElement("div"); slWrap.className = "scanline-wrap"; slWrap.innerHTML = `<div class="scanline"></div>`; QR_MOUNT.appendChild(slWrap); }
  } else { if (slWrap) slWrap.remove(); }
  let hint = QR_MOUNT.querySelector(".empty-hint");
  if (!hasData) { if (!hint) { hint = document.createElement("div"); hint.className = "empty-hint"; hint.innerHTML = `<div class="big">â–£</div><div class="txt">Enter data to generate</div>`; QR_MOUNT.appendChild(hint); } }
  else { if (hint) hint.remove(); }

  if (!shouldRebuild) return;
  _prevRenderSig = uiSig;

  // Full UI rebuild (happens on tab change, style change, etc. â€” not on every keystroke via scheduleQR)
  const tree = document.createElement("div");
  tree.appendChild(rHeader());

  const mainDiv = document.createElement("div"); mainDiv.className = "main";
  const gridDiv = document.createElement("div"); gridDiv.className = "grid";

  // Left column
  const leftCol = document.createElement("div");

  // Type selector section
  const typeSec = document.createElement("div"); typeSec.className = "sec";
  typeSec.appendChild(rTypeSelector());
  leftCol.appendChild(typeSec);

  // Content form section â€” uses persistent FORM_EL
  const formSec = document.createElement("div"); formSec.className = "sec";
  formSec.style.marginTop = "14px";
  const formLabel = document.createElement("div"); formLabel.className = "sec-label"; formLabel.textContent = "â—ˆ Content";
  formSec.appendChild(formLabel);
  formSec.appendChild(FORM_EL);
  leftCol.appendChild(formSec);

  // Customize
  leftCol.appendChild(rCustomize(status));
  gridDiv.appendChild(leftCol);

  // Right column â€” preview
  const rightCol = document.createElement("div"); rightCol.className = "preview-wrap";
  const prevSec = rPreviewPanel(rawData);
  rightCol.appendChild(prevSec);
  gridDiv.appendChild(rightCol);

  mainDiv.appendChild(gridDiv);
  tree.appendChild(mainDiv);

  // Swap root
  root.innerHTML = "";
  while (tree.firstChild) root.appendChild(tree.firstChild);

  // Transplant persistent QR_MOUNT into its slot
  const slot = document.getElementById("qr-mount-slot");
  if (slot) slot.replaceWith(QR_MOUNT);

  // Patch form inputs for current type (in-place, cursor-safe)
  buildForm(FORM_EL);

  // Update verify badge in preview header (without rebuilding)
  updateVerifyBadge();
}

function updateVerifyBadge() {
  // Find the badge container in current DOM and patch just the badge
  const prevHdr = document.querySelector(".prev-hdr");
  if (!prevHdr) return;
  let badge = prevHdr.querySelector(".vbadge");
  if (S.verifyStatus === null) { if (badge) badge.remove(); return; }

  if (!badge) { badge = document.createElement("span"); prevHdr.appendChild(badge); }
  if (S.verifyStatus === "checking") { badge.className = "vbadge checking"; badge.textContent = "âŸ³ verifyingâ€¦"; }
  else if (S.verifyStatus === "pass") { badge.className = "vbadge pass"; badge.textContent = "âœ“ canvas decoded"; }
  else if (S.verifyStatus === "fail") { badge.className = "vbadge fail"; badge.textContent = "âš  verify failed"; }

  // Also update disclaimer text
  const slot = QR_MOUNT.nextElementSibling;
  // handled by full render on sig change
}

/* â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
render();
buildForm(FORM_EL);
// Trigger initial QR if fields were restored from localStorage
if (Object.keys(S.fields).length > 0) triggerQR();
</script>
</body>
</html>
